<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Food for Thought Expected</title>
    <description>while [ 'alive' ]; do think &amp;&amp; act | tee blog; done</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 06 Jan 2020 16:52:55 +0800</pubDate>
    <lastBuildDate>Mon, 06 Jan 2020 16:52:55 +0800</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>协程在手，并发不愁</title>
        <description>&lt;ul&gt;
  &lt;li&gt;概念与实现&lt;/li&gt;
  &lt;li&gt;协程的使用&lt;/li&gt;
  &lt;li&gt;vs线程进程&lt;/li&gt;
  &lt;li&gt;协程的优点&lt;/li&gt;
  &lt;li&gt;kotlin的协程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2019.09.20在团队的分享)&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;概念与实现&quot;&gt;概念与实现&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;运行在单线程中的&lt;strong&gt;并发&lt;/strong&gt;代码段，或：&lt;/li&gt;
  &lt;li&gt;一种&lt;strong&gt;用户态&lt;/strong&gt;的轻量级线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;bonus:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;并发 vs 并行&lt;/li&gt;
  &lt;li&gt;用户态 vs 内核态&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;概念与实现-1&quot;&gt;概念与实现&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;属性&lt;/strong&gt;: 拥有自己的&lt;strong&gt;寄存器上下文&lt;/strong&gt;和&lt;strong&gt;栈&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;行为&lt;/strong&gt;: 切换时，保存当前状态或恢复之前状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可不必与特定的线程绑定，可以在一个线程中暂停，并在另一个线程中恢复&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;bonus: 对比尾递归&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;概念与实现-2&quot;&gt;概念与实现&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;有栈协程(Stackful)：有自己的调用栈&lt;/li&gt;
  &lt;li&gt;如&lt;code class=&quot;highlighter-rouge&quot;&gt;Golang&lt;/code&gt;，栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB。&lt;/li&gt;
  &lt;li&gt;无栈协程(Stackless)：没有自己的调用栈&lt;/li&gt;
  &lt;li&gt;如&lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;。上下文通过CPS(continuation-passing-style)保存，在&lt;code class=&quot;highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;中，就是一个&lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-continuation/index.html&quot;&gt;Continuation&lt;/a&gt;类，可想像成&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;bonus: &lt;code class=&quot;highlighter-rouge&quot;&gt;CPS&lt;/code&gt; vs &lt;code class=&quot;highlighter-rouge&quot;&gt;Direct Style&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;协程的使用&quot;&gt;协程的使用&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python&lt;/code&gt; 版&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 接收producer的传参，执行后面代码，直到再次碰到yield后返回producer&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;[31;1m[consumer] &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;[0m 消费 &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;# 发None启动消费者&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;[32;1m[producer]&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;[0m 生产 &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;# 暂停producer，并切换到consumer&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bonus: 对比子程序&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;协程的使用-1&quot;&gt;协程的使用&lt;/h1&gt;

&lt;p&gt;单步调试，注意&lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;(1)之后跳到了&lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;(2)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/201909/coroutine_trace.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;协程的使用-2&quot;&gt;协程的使用&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kotlin&lt;/code&gt;版：&lt;a href=&quot;https://pl.kotl.in/7s9CC8kSa&quot;&gt;playgroud&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;channel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;GlobalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[producer] 生产 $x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;GlobalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[consumer] 消费 ${channel.receive()}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bonus: 为何&lt;code class=&quot;highlighter-rouge&quot;&gt;python&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;kotlin&lt;/code&gt;版输出不同？&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;协程的使用-3&quot;&gt;协程的使用&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/201909/pipe.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;协程的使用-4&quot;&gt;协程的使用&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;子程序就是协程的一种特例。 —— Donald Knuth&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;或者说，协程是子程序的泛化。&lt;/p&gt;

&lt;h3 id=&quot;为什么&quot;&gt;&lt;em&gt;为什么?&lt;/em&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;vs-线程进程&quot;&gt;vs 线程、进程&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt; 应用程序的启动实例，有代码和打开的文件资源、数据资源、独立的内存空间。最小的资源管理单元。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;线程&lt;/strong&gt; 从属于进程，有自己的栈空间。最小的执行单元。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;表面看它们是语言特性，本质却是操作系统能力，通过API暴露给用户使用。&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;vs-线程进程-1&quot;&gt;vs 线程、进程&lt;/h1&gt;

&lt;h1&gt;&lt;img src=&quot;/img/201909/process_thread.jpg&quot; alt=&quot;&quot; /&gt;&lt;/h1&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;vs-线程进程-2&quot;&gt;vs 线程、进程&lt;/h1&gt;

&lt;h1 id=&quot;-1&quot;&gt;&lt;img src=&quot;/img/201909/coroutine_process.jpg&quot; alt=&quot;&quot; /&gt;&lt;/h1&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;vs-线程进程-3&quot;&gt;vs 线程、进程&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;谁来调度&lt;/li&gt;
  &lt;li&gt;何时切换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程/进程是os通过调度算法，保存当前的上下文实现暂停，重新开始的地方不可预期。每次CPU计算的指令数量和代码跑过的CPU时间有关，跑到os分配的cpu时间到达后就会被os强制挂起。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Coroutine&lt;/code&gt;是编译器的魔术，通过插入相关的代码使得代码段能够实现分段式的执行，重新开始的地方是&lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;关键字指定的，一次一定会运行到&lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;语句，所以本质是程序员决定何时挂起。&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;协程的优点&quot;&gt;协程的优点&lt;/h1&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// 可以轻松执行以下代码：
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GlobalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;300000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${Thread.currentThread().name} is busy calculating&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 视机器配置，可能无法运行下面代码：
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;300000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${Thread.currentThread().name} is busy calculating&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;协程的优点-1&quot;&gt;协程的优点&lt;/h1&gt;

&lt;h3 id=&quot;开销小&quot;&gt;开销小&lt;/h3&gt;
&lt;p&gt;线程的时间成本可以拆解为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;切换本身&lt;/strong&gt;的开销，主要是&lt;strong&gt;寄存器保存和恢复&lt;/strong&gt;的成本，可腾挪的余地非常有限；&lt;/li&gt;
  &lt;li&gt;执行体的&lt;strong&gt;调度&lt;/strong&gt;开销，主要是如何在大量已&lt;strong&gt;准备好的执行体中选出谁获得&lt;/strong&gt;执行权；&lt;/li&gt;
  &lt;li&gt;执行体之间的&lt;strong&gt;同步与互斥&lt;/strong&gt;成本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程的空间成本可以拆解为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;执行体的&lt;strong&gt;执行状态&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;TLS（线程&lt;strong&gt;局部存储&lt;/strong&gt;）；&lt;/li&gt;
  &lt;li&gt;执行体的&lt;strong&gt;堆栈&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;显然，上述成本的比重各不相同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;默认情况下Linux 线程在数MB 左右，其中最大的成本是堆栈。如果一个线程 1MB，那么有 1000 个线程就已经到 GB 级别了。&lt;/li&gt;
  &lt;li&gt;执行体的调度开销，以及执行体之间的同步与互斥成本，也是一个不可忽略的成本。单位成本看起来不大，但扛不住次数太多。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://web.eece.maine.edu/~vweaver/projects/perf_events/overhead/fastpath2013_perfevents.pdf#page=4&quot;&gt;for core2 and modern Linux context switch may cost 5-7 microseconds.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;bonus: 每秒多少cs是合理的？&lt;/p&gt;

&lt;h3 id=&quot;不易出错&quot;&gt;不易出错&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;共享变量的同步锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程的任务分配是&lt;strong&gt;抢占式&lt;/strong&gt;，存在共享变量时，需要使用锁来保证线程间数据安全。
协程间任务分配是&lt;strong&gt;分发式&lt;/strong&gt;，本身无此问题，但&lt;strong&gt;如果运行在多线程中，依然有问题&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;No silver bullet&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;协程的应用&quot;&gt;协程的应用&lt;/h1&gt;

&lt;p&gt;协程主要应用场景是高性能的&lt;strong&gt;网络服务&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;来自客户端的请求包和服务器的返回包，都是网络IO；&lt;/li&gt;
  &lt;li&gt;过程中，需要访问存储来保存和读取自身的状态，也涉及本地或网络IO。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果用多线程来实现，如上所述，成本高，易出错。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;kotlin协程&quot;&gt;Kotlin协程&lt;/h1&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineContext&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EmptyCoroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineStart&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineContext&lt;/code&gt;: 可以理解为协程的上下文，其中一个实现&lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt;支持4种线程模式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Dispatchers.Default, 默认线程池, &lt;code class=&quot;highlighter-rouge&quot;&gt;CPU-heavy&lt;/code&gt;任务&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html&quot;&gt;Dispatchers.IO&lt;/a&gt;, 适合&lt;code class=&quot;highlighter-rouge&quot;&gt;IO-heavy&lt;/code&gt;任务&lt;/li&gt;
  &lt;li&gt;Dispatchers.Main, 主线程&lt;/li&gt;
  &lt;li&gt;Dispatchers.Unconfined, 没指定，就是在当前线程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;kotlinx.coroutines.*&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GlobalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// launch a new coroutine in background and continue
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1000L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// non-blocking delay for 1 second (default time unit is ms)
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;World!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// print after delay
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello,&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// main thread continues while coroutine is delayed
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2000L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// block main thread for 2 seconds to keep JVM alive
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;参考资料&quot;&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md&quot;&gt;Kotlin Coroutines Design Proposal&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/basics.html&quot;&gt;Kotlin Coroutine Reference&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html&quot;&gt;Shared mutable state and concurrency&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do&quot;&gt;What does the “yield” keyword do&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=YrrUCSi72E8&quot;&gt;Deep Dive into Coroutines on JVM&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zingp/p/5911537.html&quot;&gt;协程及Python中的协程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/76d2f47b900d&quot;&gt;kotlin - Coroutine 协程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.itboth.com/d/J3uE7v/context-cpu-switch-context-switch-java&quot;&gt;从Java视角理解CPU上下文切换&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 20 Sep 2019 14:30:09 +0800</pubDate>
        <link>http://localhost:4000/computer/2019/09/20/coroutine.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer/2019/09/20/coroutine.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>Queuing Theory——排队的艺术</title>
        <description>&lt;p&gt;近期团队遇到相关场景，把2016年在堆糖做过的分享搬出来做了点完善，再分享一次：&lt;a href=&quot;/pdf/queuing-theory.pdf&quot;&gt;排队的艺术&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Jan 2019 14:30:09 +0800</pubDate>
        <link>http://localhost:4000/computer/2019/01/29/queuing-theory.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer/2019/01/29/queuing-theory.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>像代数推导一样编程</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;In math we trust——张首晟&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;纯函数已然为函数式编程赢得了巨大优势，但这还不够。纯函数还只是一块基石，它和另一块基础——数据不可变，一道构筑了函数式编程蔚为壮观的独特风景：代数推导。这是函数式编程最吸引我的地方，因为，数学终于从编程语言或者计算机科学的背后走向前台，让我们可以像代数推导一般，进行现实问题的建模和编码。根据张首晟教授的说法，区块链的信任机制本质上是对数学的信任。我想，这一样适用于函数式编程，数学的严谨性让模型和代码质量有了更多保障。而数学的抽象，让貌似不同的事物有了变成一样的可能，提高了代码的普适性。&lt;/p&gt;

&lt;p&gt;学习函数式编程，与其说是学习某门具体的语言，不如说是学习如何运用代数结构描述现实事物，运用代数式子表达现实逻辑，运用代数推导求解现实问题。&lt;/p&gt;

&lt;h3 id=&quot;面向表达式语言&quot;&gt;面向表达式语言&lt;/h3&gt;
&lt;p&gt;代数，简而言之，研究的是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对象的&lt;strong&gt;集合&lt;/strong&gt;，这里的对象不是编程语言里的对象，反倒是更像类型。&lt;/li&gt;
  &lt;li&gt;用对象创建新对象的&lt;strong&gt;操作&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如，数构成集合，加减乘除构成操作。&lt;/p&gt;

&lt;p&gt;介绍纯函数时，我们知道了数学上的运算可以写成纯函数，如&lt;code class=&quot;highlighter-rouge&quot;&gt;f(x) = 2 * x + 3&lt;/code&gt;可以写成&lt;code class=&quot;highlighter-rouge&quot;&gt;def f(x: Int) = x * x + 3&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;f(x, y) = x + y&lt;/code&gt;写成&lt;code class=&quot;highlighter-rouge&quot;&gt;def f(x: Int, y: Int) = x + y&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;集合里的对象，也就是语言的类型，后面再辟专门的章节讲述。先看看看代数的推导过程，蕴含了哪些值得借鉴的做法。以下是一道简单代数题的求解过程：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;已知函数f(x + 2) = 2x^2 - 5x + 1，求f(x)。
解：
设 t = x + 2, 则x = t - 2
∴ f(t) = 2 * (t - 2)^2 - 5 * (t - 2) + 1
∴ f(t) = 2 * (t^2 - 4 * t + 4) - 5 * t + 10 + 1
∴ f(t) = 2 * t^2 - 13 * t + 19
即，f(x) = 2 * x^2 - 13 * x + 19
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以发现：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先，在整个推导过程中，保持变量含义的不变，从头到尾的一致性。不会突然令&lt;code class=&quot;highlighter-rouge&quot;&gt;x = 9&lt;/code&gt;或别的值，当需要表达其它量时，启用新的变量t，并表述清楚t的来源&lt;code class=&quot;highlighter-rouge&quot;&gt;t = x + 2&lt;/code&gt;，而不是复用原来的变量：&lt;code class=&quot;highlighter-rouge&quot;&gt;x = x + 2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有人把变量的&lt;strong&gt;不可变性&lt;/strong&gt;视为函数式编程最重要的特性，因为，就像上述推导一样，它喻示着过程的可省视性。仅仅通过阅读代码，就可以理解整个逻辑，而不是指令式编程那样，必须在脑子里”运行”代码。当大脑无法跟踪太多变量的变化时，不得不借用纸笔或调试工具来debug，只消几层的if判断就足以把人绕晕。有了不可变性，可以放心地将代码的各个部分分离开，独立解读，脑子里要保留、跟踪的信息几乎不随代码规模的增长而增加。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;其次，在值相同的情况下，符号和表达式可以互相替代，如&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;x + 2&lt;/code&gt;在通篇任意位置可以互相替代，这种替代在数学上叫&lt;strong&gt;换元&lt;/strong&gt;，用于辅助推导，并不改变语义。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若要在代码层面“换元”，则要求满足引用透明，引用透明辅助编译器对代码做优化，如果没有引用透明，编译器无法自由地替换“表达式“和“值”，因为前后两次的执行结果可能不同，哪怕结果完全一样，程序只能无奈地一次次对该表达式做求值操作。也不能改变表达式的顺序，因为前后两次的求值结果可能不一样，进而限制了程序的并发性。&lt;/p&gt;

&lt;p&gt;代数也是一门语言，它用数学模型描述现实世界，并解决逻辑问题。如果把它也看成一门编程语言，它应该归入什么类别呢？大概“面向表达式语言”是比较合理的分类。没错，表达式！看上面代数题的求解过程，本质是表达式的归约操作、合并同类项操作。所谓归约，就是将每个最内层可归约表达式用其值来替换，这样又形成了新的最内层可归约表达式，然后再对其进行归约，最后，整个程序全部被归约，仅留下最终结果。&lt;/p&gt;

&lt;p&gt;所以，用它解决问题的过程应该是，用数字或符号描述现实世界，如直角三角形的两和直角边长度分别为a和b，依据放之四海而皆准的公理，如勾股定理，构建它们的逻辑关系，如斜边&lt;code class=&quot;highlighter-rouge&quot;&gt;c^2 = a^2 + b^2&lt;/code&gt;
，再用加减乘除等运算操作，简化、规约表达式，求得斜边长度。这一过程中，我们并没有过问这些变量寄存在哪里（有人直接在脑子里算，也有人要在纸上演算），也不关心它们是否复用了同一块内存，会不会被其它人错误地读写了。我们关心的是想要什么，得到结果的逻辑是什么，而不是如何赋值、如何改写变量。前者是人类擅长的，后者是机器擅长的。我们应让机器服务人类，而不是反过来，人类迁就机器。为此，我们需要一个工具，把高阶的人类思维忠实地转换为低阶的机器语言。&lt;/p&gt;

&lt;p&gt;函数式语言就是这样的工具，它有一个少为人知的别名，正是“面向表达式语言”。&lt;strong&gt;表达式&lt;/strong&gt;是值和逻辑（函数）的组合，讲究如何编织逻辑以创建新的值，执行的过程即是规约化得到最终结果的过程，如：&lt;code class=&quot;highlighter-rouge&quot;&gt;val total = sum(list)&lt;/code&gt;，sum是一个求和的运算逻辑，通过这个逻辑得到值&lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt;。 与之相反的是&lt;strong&gt;指令式&lt;/strong&gt;，用一系列的执行单元，告诉计算机如何改变指令计数器、数据存储器、当前计数状态等，通过状态的改变得到最终结果，如：&lt;code class=&quot;highlighter-rouge&quot;&gt;list.sum()&lt;/code&gt;，sum是个运算指令，它不返回计算的值，而是改变了某个状态，通过读取这个状态的地址得到结果。&lt;/p&gt;

&lt;p&gt;指令式语言让我们从低级语言的内存、栈、寄存器等概念中解脱，却依然是指令运行过程的封装：循环、锁、线程、并发。函数式语言则进一步抽象，更多地让编译器、解析器处理这些概念，让人腾出更多精力关注数据模型、关注业务逻辑。&lt;/p&gt;

&lt;h3 id=&quot;函数的组合&quot;&gt;函数的组合&lt;/h3&gt;
&lt;p&gt;他山之石，可以攻玉。我们回头再挖掘下代数里可以借鉴的特质。&lt;/p&gt;
&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果f(x) = 3x - 1，且g(x) = x^3 + 2，那么f(g(3))的值是多少？
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;间接的做法是，先求得&lt;code class=&quot;highlighter-rouge&quot;&gt;g(3) = 29&lt;/code&gt;，进而&lt;code class=&quot;highlighter-rouge&quot;&gt;f(g(3)) = f(29) = 86&lt;/code&gt;。那么，有没有直接的做法呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/201810/compose_func.png&quot; alt=&quot;compose&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了直接计算&lt;code class=&quot;highlighter-rouge&quot;&gt;f(g(x))&lt;/code&gt;，我们得&lt;strong&gt;组合&lt;/strong&gt;（Composition）f和g这两个函数。由于&lt;code class=&quot;highlighter-rouge&quot;&gt;g(x)&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;f(x)&lt;/code&gt;的输入，可以把&lt;code class=&quot;highlighter-rouge&quot;&gt;f(x)&lt;/code&gt;的各个&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;替换为&lt;code class=&quot;highlighter-rouge&quot;&gt;g(x)&lt;/code&gt;，得到&lt;code class=&quot;highlighter-rouge&quot;&gt;f(g(x)) = 3g(x)-1 = 3x^3+5&lt;/code&gt;，即是图中绿线所表示的函数。&lt;/p&gt;

&lt;p&gt;在Scala里，&lt;code class=&quot;highlighter-rouge&quot;&gt;Function1&lt;/code&gt;接口定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;compose&lt;/code&gt;方法和&lt;code class=&quot;highlighter-rouge&quot;&gt;andThen&lt;/code&gt;方法，均可以用来组合单参数函数。&lt;code class=&quot;highlighter-rouge&quot;&gt;f(g(x))&lt;/code&gt;可以写成：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;f: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;g: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fg&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compose&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fg2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;andThen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意，”_“表示Eta expansion。&lt;/p&gt;

&lt;p&gt;组合看上去再自然不过了，以至于我们不觉得有什么特别或厉害的。然而，稀松平常的组合却透露了编程的本质。&lt;/p&gt;

&lt;p&gt;我们是如何解决问题的？每当碰到复杂的问题，就把它分解为更小的问题，直到问题足够小，小到我们可以写代码解决它。然后，再组合这些小颗粒度的代码，形成原始问题的解决方案。问题规模的限制并不是计算机强加给我们的，而是人类大脑的限制。1956年发表的著名论文《神奇的数字 7，加减 2：人类信息加工容量的某些局限》指出，不管记忆的内容怎么变化，是数字，字母，数字 + 字母，还是从 1000 个单音节单词中随机选，人们在记忆这些材料的时候，大概只能记住 5-9 个。所以，我们必须把一次性可以处理的代码块规模控制在大脑可以接受的程度。所谓”优雅代码”，不是结构清晰、简洁所能概括的，更切中要害的说法是，可被有限的大脑带宽处理。&lt;/p&gt;

&lt;p&gt;分解本身不是目的，解决问题需要重组这些子块，如果无法重新组合，分解的意义就不存在。什么样的函数能组合呢？显然，一个函数的输出类型必须和另一个函数的输入类型保持一致。至少在函数式语言内，这是”类型”概念存在的根本原因。有关类型，我们后面再详谈。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文节选自&lt;a href=&quot;https://github.com/vitrun/scalazen&quot;&gt;《函数式思维学习录》&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Oct 2018 14:30:09 +0800</pubDate>
        <link>http://localhost:4000/computer/2018/10/29/fp-algebra.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer/2018/10/29/fp-algebra.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>纯函数的好处</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;哦，雪白的纯朴具有何等大的威力！——济慈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;纯函数的两个优良品质，为它赢得了很多优势。&lt;/p&gt;

&lt;h4 id=&quot;引用透明&quot;&gt;引用透明&lt;/h4&gt;
&lt;p&gt;以直接用函数运行的结果替代函数表达式本身而不改变程序的最终结果，称为引用透明（Referential Transparent）。如：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;world&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果把第二处”hello”.length换成x，或者反过来，把第二处y换成”world”
.length，并不改变z的值。这似乎是很显然的事，却是以length是纯函数为前提的，换成随机数生成函数、获取当前时间的函数，就不能替换。如果改变函数范围外的变量，也会破坏引用透明，如：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//false
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;记忆&quot;&gt;记忆&lt;/h4&gt;
&lt;p&gt;引用透明很好，可避免函数的反复执行，但毕竟还是需要人工替换，如果函数自身能智能地实现一次计算，多处使用就好了。可喜的是，对于纯函数，编译器可以实施名为”记忆”（Memoization)的优化技术，正是达到这个效果。特别是执行很费时的函数，把结果缓存起来，当下次用相同入参调用时，便可直接返回缓存的结果，不再重新计算，大大提高程序的效率。当然，通过把入参和结果作为键值对保存在Map中，我们可以自己实现缓存过程，方便控制缓存策略。用通常不太缺乏的内存空间换取宝贵的计算时间，这是计算机科学里常用的”伎俩”。&lt;/p&gt;

&lt;h4 id=&quot;缓求值&quot;&gt;缓求值&lt;/h4&gt;
&lt;p&gt;缓求值(Lazy Evaluation)，指尽可能地推迟求解表达式，是函数式编程语言常见的一种特性。Scala通过lazy关键字声明缓求值。缓求不会在遇到表达式时就触发运行，而是在用到的时候才真实计算。缓求在记忆之外，为昂贵的运算提供了另一种优化手段。如，以下判断质数的函数，虽然表达式&lt;code class=&quot;highlighter-rouge&quot;&gt;isPrimeSlow(num)&lt;/code&gt;在if判断前面，但只有当输入为奇数时，才会真正被执行。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isPrimeSlow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isPrime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;lazy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isPrimeSlow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;缓求值在集合中的应用更能体现其价值。熟悉Python的同学知道生成器（generator）的概念，应用了缓求了集合与之类似，对于很大的集合，不是一次性生成（或者说根本就没有生成），只是需要的时候才吐出所需的元素。对比intsEager和intsLazy执行效果，便会发现对于寻找大于5的第一个数6而言，intsEager一次性生成了10万个元素，但比6大的元素对于求解结果毫无帮助，白白浪费了内存，简直是暴殄天物。如果把这个形式推到极限，对于有无限个元素的集合，似乎只有缓求方式才能胜任了。这下我们发现了，相比于”记忆”，缓求倒过来了，它是以临时计算来免除需要事先准备好的内存。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intsEager&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;intsEager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intsLazy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;intsLazy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上，是纯函数为语言提供的额外特性，可以认为是一些与身俱来的优势。接下来分析纯函数为编程实践带来的好处，如何帮助提高代码质量，提高开发效率。&lt;/p&gt;

&lt;h4 id=&quot;纯函数更易推断&quot;&gt;纯函数更易推断&lt;/h4&gt;
&lt;p&gt;纯函数的签名已经把它的目的和盘托出了，不需要细看内部实现，就可以相信它没有多干其它小动作，所以不会有超乎签名的副作用和意外效果。经验不足的同学甚至在java的getter类方法中做了写操作：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;visit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;哪怕老手也难免有被糊弄的时候。比如，出乎意料，下面这段代码会访问网络，因为URL的hashCode方法会尝试解析域名。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;notPure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;URL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://example.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Sets&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MalformedURLException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//ignored&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;纯函数就没有这些问题，这是多么大的心智减负。&lt;/p&gt;

&lt;h4 id=&quot;纯函数更易组合&quot;&gt;纯函数更易组合&lt;/h4&gt;
&lt;p&gt;函数的组合（compose)，简单而言，就是把若干函数按一定顺序拼接组成新函数。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;后续会介绍，组合在函数式编程中有着举足轻重的地位。且看组合的具体应用——优雅的链式调用：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doThis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thenThis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;andThenThis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doThisToo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;andFinallyThis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果不是纯函数，很难想象可以放心地写出这段代码。doThis(a)如果改变了a，会怎么影响doThisToo的行为？如果各步骤共享了状态，拋了异常，代码的整体行为表现是怎样的？正确评估这些问题极其消耗心力。而纯函数的确定性，可以让后续步骤放心地依赖前面步骤的输出，代码的作用如字面语义一样跃然纸上。&lt;/p&gt;

&lt;h4 id=&quot;纯函数更易测试和定位问题&quot;&gt;纯函数更易测试和定位问题&lt;/h4&gt;
&lt;p&gt;唯一能影响函数行为的只有输入参数，没有不为人知的魔法，没有数据库、磁盘读写，所以不用关心函数外的环境因素，进而在不同人的电脑上debug效果一样。同理，指令式编程过程中费时费力的单步调试，此时不再重要了，关心函数的输出即可。&lt;/p&gt;

&lt;h4 id=&quot;纯函数更易并发&quot;&gt;纯函数更易并发&lt;/h4&gt;
&lt;p&gt;纯函数保证值不变性，值一旦生成就不再改变，无论是同一线程还是多个线程，都不允许修改。所以连锁都免了，更没有死锁或数据竞态问题了。&lt;/p&gt;

&lt;p&gt;因为没有副作用，从出入参就可以看出函数之间的依赖关系，如果前后没有数据依赖，其先后顺序便可以交换，或者在多个线程中独立运行而不相互干涉。如下面代码中，f、g、h在字面上的先后顺序是固定的，但编译器完全可以根据需要改动实际执行顺序，或者优化为并发执行。如果它们有副作用，比如暗地里修改了共享的状态，就不能这么轻巧地优化了。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们从回顾众所周知的函数开始，再区分纯函数和非纯函数，进而专注于纯函数式的特点、好处。接下来，如何不是特别说明，提到函数时指的就是纯函数。函数式编程，更准确的说法应该是”纯函数”式编程。纯函数所带来的好处构成了函数式编程的核心优势，这点后续将有更多体现。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文节选自&lt;a href=&quot;https://github.com/vitrun/scalazen&quot;&gt;《函数式思维学习录》&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 20 Oct 2018 14:30:09 +0800</pubDate>
        <link>http://localhost:4000/computer/2018/10/20/why-pure-function.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer/2018/10/20/why-pure-function.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>纯函数的特质</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;大人者，不失其赤子之心者也。——孟轲&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;数学家比较幸福的一点是，他们研究的函数是”纯净”的。没有异常，没有意外，同样的入参一定返回同样的结果。如果不是，那就是人出错了。&lt;/p&gt;

&lt;p&gt;编程里的函数就没这么纯粹，会遇到无法处理的输入，会在中途拋出异常，在返回值之外会留下别的痕迹。这些不确定性因素，使得人们不能放心大胆地使用函数。因此，需要一个标准，把有这类特点的问题函数识别出来，让”纯函数”发扬光大。&lt;/p&gt;

&lt;p&gt;“纯函数”具备以下性质：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;确定性&lt;/strong&gt; 相同的入参，一定返回相同结果，不受内部隐藏状态、隐藏值的影响，也不受任何I/O的影响。多次调用的结果保持一致，说明纯函数具有幂等性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;无副作用&lt;/strong&gt; 运行函数不能引发可辨别的副作用或输出，如修改可变对象，或写入I/O设备。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;展开来讲，纯函数应该避免：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;读取函数之外的任何值，如所在类的属性，或全局变量。&lt;/li&gt;
  &lt;li&gt;修改函数之外的任何对象，如所在类的属性或全局变量。&lt;/li&gt;
  &lt;li&gt;依赖任何I/O操作，如从本地文件、数据库、API、屏幕等途径读取或写入内容。&lt;/li&gt;
  &lt;li&gt;修改输入参数。&lt;/li&gt;
  &lt;li&gt;拋出异常。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回顾之前的定义，对于数学意义上的函数，定义域的元素总能唯一对应值域的元素，加上数学是一种逻辑符号语言，自然没有副作用。那么不难理解，表达这些数学含义的代码函数（scala.math._里定义的函数）也应该是纯函数，如：square, min, max, abs等。或者你自定义的计算，如：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;squareSum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;很多常用类的方法，并不改变方法之外的类属性，也不进行I/O操作，也是纯函数。如String的charAt, isEmpty, length；集合类型的drop（没错，drop也是）, filter, map等。&lt;/p&gt;

&lt;p&gt;再来看看纯函数的反例。同样是数学上的运算，如果函数拋出异常，就不纯了，因为异常时没有和输入对应的结果。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;divide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;divide&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;x:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;y:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;divide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArithmeticException&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;zero&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也不是所有集合类的方法都是纯函数，foreach方法就是专门为副作用准备的。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Unit在scala中表示”没有东西”，如果一个函数接受了输入，但不返回任何结果，那么它做的工作就只能是”副作用”了。&lt;/p&gt;

&lt;p&gt;常见的非纯函数还有：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;getDayOfWeek，getHour，getMinute等方法，因为不同时刻调用它们得到的结果不同。&lt;/li&gt;
  &lt;li&gt;scala.util.Random中用于生成随机数的nextInt，因为返回值依赖了输入之外的隐藏状态。&lt;/li&gt;
  &lt;li&gt;I/O操作，如&lt;code class=&quot;highlighter-rouge&quot;&gt;def println(x: Any): Unit&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;def readLine(): String&lt;/code&gt;。所以，当发现签名的入参为空或出参为Unit时，就得擦亮眼睛了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，面向对象语言里常见的setter方法，或改变了所在对象的状态的方法也不是纯函数，如：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;pureFunction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;至此，我们已经能辨别纯函数，可纯函数有什么好处呢？&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文节选自&lt;a href=&quot;https://github.com/vitrun/scalazen&quot;&gt;《函数式思维学习录》&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 05 Oct 2018 14:30:09 +0800</pubDate>
        <link>http://localhost:4000/computer/2018/10/05/what-is-pure-function.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer/2018/10/05/what-is-pure-function.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>默克尔树（Merkle Tree）</title>
        <description>&lt;p&gt;默克尔树（Merkle Tree）的定义很简单，却是区块链技术领域的重要概念。它使得大规模的分布式区块网络成为可能，也让普通机器可以成为网络节点。&lt;/p&gt;

&lt;h3 id=&quot;什么是默克尔树&quot;&gt;什么是默克尔树&lt;/h3&gt;
&lt;p&gt;数据结构上，它是一种特殊的二叉树(也可以是多叉树)，设计如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;叶子节点的值是数据的哈希值。&lt;/li&gt;
  &lt;li&gt;非叶子节点的值是其所有子节点的哈希值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/2018.3/merkle_tree.png&quot; alt=&quot;&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;hash代表哈希算法，如MD5，SHA系列等，可把任意长度的数据转换为固定长度的哈希值。&lt;/li&gt;
  &lt;li&gt;L1, L2等是叶子节点对应的数据，直接作为哈希算法的输入。&lt;/li&gt;
  &lt;li&gt;非叶子节点的哈希输入为所有对应子节点哈希串的拼接。&lt;/li&gt;
  &lt;li&gt;最终形成唯一的根节点，称为默克尔根(Merkle Root).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上图叶子节点数为4，恰好每一层都有完整输入。如果叶子节点数量不是2的次方，即不能形成满二叉树，怎么处理呢？&lt;/p&gt;

&lt;p&gt;有多种处理“孤立”叶子节点的方式。一种方案是不断重复最后一个节点，直到整体数量达到2^n
个。这种方案的想法比较直接，缺点也很明显，多做了很多无用功。比较好的方法是，把“孤立”节点提升到更高层次中。具体提到哪一层，要看叶子节点的数量情况，下图展示了5-7个叶子节点的情况：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     ┌───┴──┐          ┌────┴───┐            ┌─────┴─────┐
  ┌──┴──┐   │       ┌──┴──┐     │         ┌──┴──┐     ┌──┴──┐
┌─┴─┐ ┌─┴─┐ │     ┌─┴─┐ ┌─┴─┐ ┌─┴─┐     ┌─┴─┐ ┌─┴─┐ ┌─┴─┐   │
       (5)                 (6)                    (7)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;默克尔树的特性&quot;&gt;默克尔树的特性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;对变动敏感&lt;/strong&gt;。任何细微的变动都会引发叶子节点哈希值的变化，依次向上传导，最终导致根节点的变动。因此，像普通哈希一样，可以用来验证数据拷贝的一致性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;快速定位差异&lt;/strong&gt;。二叉树查询的时间复杂度为O(logN)，沿着根节点向下对比，可以非常高效地确定具体是哪个（些）叶子的数据有差异。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;默克尔证明&lt;/strong&gt;。如图，要证明数据d3在数据集中，只要知道节点c,i,n（白色节点）的值，即可通过重新计算节点d,j,m的值，进而计算根节点的值，再和给定的根节点对比，判断d3是否属于该数据集。不需要拿到所有数据，即可完成此验证。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/2018.3/merkle_proof.jpeg&quot; alt=&quot;&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;默克尔树的应用&quot;&gt;默克尔树的应用&lt;/h3&gt;

&lt;h4 id=&quot;p2p下载&quot;&gt;P2P下载&lt;/h4&gt;
&lt;p&gt;在p2p下载出现之前，整个文件的数据都从一个中心节点上获取。这个中心节点的资源和稳定性常常成为瓶颈点，一旦下载异常，整体文件都需要重新下载。p2p
网络出现后，一个大文件被分割成许多小块，编号后分布在不同的资源节点上，下载操作同时从多个节点上进行，每一块都有对应的哈希值，用于下载后的检验。就算一个块出错，只需要重新下载这小块就行，而不需要重新下载整个文件。&lt;/p&gt;

&lt;p&gt;问题是如何确保每一块的哈希值本身是正确的呢，在p2p
网络中，任何人都可以成为提供下载资源的节点，无法确保数据本身或其哈希值没被恶意修改。一种方式是由可靠的权威节点提供这些小块数据的哈希值，可以从做任意节点下载资源，但只从权威节点下载哈希值。这当然可行，但对权威节点的依赖还是太大了。&lt;/p&gt;

&lt;p&gt;默克尔树能解决这个问题呢？把小块数据作为叶子节点，构建默克尔树，只要根节点的哈希值从可信节点下载，剩下所有数据和节点哈希值都可以从任意节点下载。各个分支的值可以对其子树进行检测，根的值则可以对整个默克尔树进行检测。这样既可以各个分支并行独立处理，又确保了整个大文件的完整性。&lt;/p&gt;

&lt;h4 id=&quot;比特币交易验证&quot;&gt;比特币交易验证&lt;/h4&gt;

&lt;p&gt;比特币的设计里，区块头是不包含交易（Transaction）信息的，关于交易的数据只是交易构建的默克尔树的根节点。
&lt;img src=&quot;/img/2018.3/blockchain.jpeg&quot; alt=&quot;&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而比特币网络的轻量客户端（如钱包）又不存储完整的区块数据，仅下载区块头，就能验证某笔交易是否被打包到链上。这是如何做到的呢？客户端验证步骤如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先对交易数据进行哈希。&lt;/li&gt;
  &lt;li&gt;然后咨询完整节点：这个哈希值对应的交易是否在第index
个区块中？&lt;/li&gt;
  &lt;li&gt;完整节点的区块不会直接返回在或不在的结论，而是返回一个&lt;em&gt;默克尔证明&lt;/em&gt;（重新计算根节点所需的路径）。&lt;/li&gt;
  &lt;li&gt;客户端验证这个”默克尔证明”，即独立计算根节点的哈希值。&lt;/li&gt;
  &lt;li&gt;对比区块头中的哈希值与计算结果是否相同。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于n笔交易而言，路径节点数只要log2(n)，无论是查找还是数据传输都是一个巨大的效率提升。不妨试算一下，假设某个区块包含32768笔交易，每笔交易占256字节，则所有交易大小为8M
，而路径数为15，每个哈希占32字节，则路径大小仅为480字节，差距高达5个数量级。&lt;/p&gt;

&lt;p&gt;值得指出的是，比特币网络的任何节点都不会也没必要相信其它节点，节点只能依赖事先约定的协议独立地验证来自网络的数据。这个验证的最终基础正是数学。用张首晟的话说：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;In math, we trust.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然，默克尔树早在比特币之前就已经广泛使用了，分布式代码版本工具Git，以及开源数据库Apache Cassandra均有使用。&lt;/p&gt;

&lt;h3 id=&quot;默克尔树的实现&quot;&gt;默克尔树的实现&lt;/h3&gt;
&lt;p&gt;为了加深理解，用python实现了简单的默克尔树，包含构建、验证和查找功能。数据结构本身比较清楚明了，关键代码做了注释，这里不再讨论。可直接到&lt;a href=&quot;https://github.com/vitrun/pok/tree/master/merkletree&quot;&gt;github&lt;/a&gt;阅读源码。&lt;/p&gt;

&lt;h3 id=&quot;参考文档&quot;&gt;参考文档&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;https://github.com/adjoint-io/merkle-tree&lt;/li&gt;
  &lt;li&gt;https://en.wikipedia.org/wiki/Merkle_tree&lt;/li&gt;
  &lt;li&gt;https://brilliant.org/wiki/merkle-tree/&lt;/li&gt;
  &lt;li&gt;https://juejin.im/entry/5a2e1135f265da432f311168&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 08 Jul 2018 14:30:09 +0800</pubDate>
        <link>http://localhost:4000/computer/2018/07/08/merkle-tree.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer/2018/07/08/merkle-tree.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>编程界的剑气之争</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/2017.4/kungfu.jpeg&quot; alt=&quot;&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;华山派曾有剑宗和气宗之分。双方你争我夺，势不两立。是权力之争，也是道统和武力之争。&lt;/p&gt;

&lt;p&gt;咱编程界也有指令式程序（如，面向对象）和函数式编程两派。他们的关系虽不至于剑拔弩张，却也相当紧张。表面是语言风格之争，其实是方法论之争。&lt;/p&gt;

&lt;p&gt;话说，当年高级语言诞生不久，场面就开始混乱了。面向对象派，又称bottom-up派，他们从底层硬件开始向上走，在不牺牲性能的前提下，逐步增加抽象层级，不断接近数学。Fortran, C/C++, Pascal, Java以及C#等等都属于这派。函数式编程派，又称top-down派，坚持从数学出发，逐渐减少抽象级别，以接近现实问题，并获得硬件支持，为了保持概念完整，牺牲了部分性能。其拥护者有Algo，Lisp，Smalltalk和Haskell等。&lt;/p&gt;

&lt;p&gt;双方坚持信仰，互相揭短。top-down说，哎呀，别这么快向硬件妥协，那会把选择局限在少数几个不可逆的设计中；而且，mutable太可怕了，尤其是在并发情况下，冷不防就来个意外。bottom-up派则说，别给我套这么多数学，我很难兼顾垃圾回收、函数调用……而且，性能、性能、性能，我不能牺牲任何性能；immutable太理想化了，毕竟现实世界在变，试想，如果date和random不变，调用它们有什么意义？&lt;/p&gt;

&lt;p&gt;计算机科学家Erik Meijer说，每当新语言出现时，他总会看看技术规范。这对他来说，也许就像喝着咖啡看报纸，轻松自如。但他在一次分享中说，有一门语言，他根本读不懂，一看就犯困，比什么安眠药都更有效。你可能会觉得那一定是门高深的语言，然而，这门语言就是很多人熟悉的Java8。他觉得lambda，method reference这些东西实在太复杂了。怎么办？每当碰到复杂的东西，他就听Leslie Lamport（图灵奖获得者）的话：“我们应该多用点数学。”&lt;/p&gt;

&lt;p&gt;他知道，大部分程序员都惧怕数学，就更别说如何用数学理解语言，如何在编码中应用数学。所以他上台演示，分享了《Category Theory, The essence of interface-based design》。老头子精力十足，对照着讲数学概念和函数式编程中的语言概念，很是精彩。时不时揶揄下Java：lambda演算早在1928年就提出了，Java作者Gosling一度声称没必要支持lambda，但最终还是在Java8中支持了，这是为什么？因为我们畏惧数学。但我们不应该畏惧，搞数学的人都是很聪明的，我们应该从他们身上偷师点东西。&lt;/p&gt;

&lt;p&gt;年迈的Java徘徊良久，终于接纳函数式编程；年轻的Scala和F#是与身俱来的多面手，两边讨好；新生的Kotlin长了一张面向对象的脸，却又兼俱一点函数式气质。争吵了近70年，两派终于开始弥合了。&lt;/p&gt;

&lt;p&gt;纵是阳春白雪， 也有下里巴人的时候。多核时代下并发需求的普及，以及日益复杂的软件架构，使得指令式编程力不从心。我们需要更有力的武器。Brian Beckman说，我们将无可避免地接触monad，因为函数式编程正迎面呼啸而来。&lt;/p&gt;

&lt;p&gt;这段历史似曾相识，关于剑气宗的高下，岳不群有段论述：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;剑宗功夫易于速成，见效极快。大家都练十年，定是剑宗占上风；各练二十年，那是各擅胜场，难分上下；要到二十年之后，练气宗功夫的才渐渐的越来越强；到得三十年时，练剑宗功夫的便再也不能望气宗之项背了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但我们是文明的现代人，何必争个你死我活。我们要融合，要扬长避短。总有一天，犹太教、基督教和伊斯兰教的朋友们会在他们共同的圣地——耶路撒冷，愉快地生活的，是不是？哦弥陀佛！&lt;/p&gt;

&lt;p&gt;有个问题摆在所有程序员面前：如何提高软件质量？这是个可以写好几本书的话题。我敢打包票的是，这些书都会讲code review、unit test、 QA……其中单元测试（或者包括集成测试）的争议最大。写测试确实费时费力，又不一定讨好。我认识的人中就有坚决肯定和坚决否定两种极端。我认为这是个性价比的问题，如果能自动生成单元测试就好了。于是，一度想用AI搞个这样的项目（事实是确实有人在研究这个，比如randoop，曾测出了jdk的bug）。但转念一想，又打住了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;People are always more willing to work harder than they have to than to work smarter than they’re able to.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;质量的关键并不在测试之类的防御性措施上。测试是有意义的，但就像公路两边的防护栏，能防止你掉下悬崖，却并不能把你带向目的地。我们应该回到业务本身，琢磨如何更优雅地设计和实现它，这是科学、艺术，是编程之美，也是我一直提倡design review的原因。但关于设计以及架构，我发现的更多是其中的“艺术”成分，也就是依靠经验和模仿习得的那些。是否有完整的章法和可言传的套路呢？我们需要更多科学来指导代码的设计和组织。与其说我们需要函数式编程，不如说我们需要更高的视角看待编程。&lt;/p&gt;

&lt;p&gt;带着这个疑问，我撞见了category theory，中文叫范畴论，不知道这个鬼见了都犯愁的理论，能多大程度解决问题。但我愿意一试，没准某一天，我能以气御剑？&lt;/p&gt;

&lt;p&gt;注：上面都是废话，本文重点是以下链接：&lt;/p&gt;

&lt;p&gt;REF.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;https://www.infoq.com/presentations/Simple-Made-Easy&lt;/li&gt;
  &lt;li&gt;https://www.youtube.com/watch?v=ZhuHCtR3xq8&lt;/li&gt;
  &lt;li&gt;https://www.youtube.com/watch?v=JMP6gI5mLHc&lt;/li&gt;
  &lt;li&gt;https://ykode.id/making-sense-of-category-theory-6f901e39fa3c&lt;/li&gt;
  &lt;li&gt;https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 06 Dec 2017 12:15:09 +0800</pubDate>
        <link>http://localhost:4000/computer/2017/12/06/fp-vs-op.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer/2017/12/06/fp-vs-op.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>程序员的核心能力</title>
        <description>&lt;p&gt;程序员要掌握的知识，要具备的能力实在太多，多得头发都不够掉。&lt;/p&gt;

&lt;p&gt;大体有两大方向。一是对工具的熟练掌握，如操作系统、网络、IO、编程语言等；另一个是用代码为现实问题生成解决方案的能力，这其中最重要的是抽象能力。&lt;/p&gt;

&lt;p&gt;前一个方向是很容易意识到的，很多现象可以说明这一点，比如，世面上介绍如何使用语言、框架的书汗牛充栋；比如，很多人眼里进这一行的门槛是上1个月的语言培训课。&lt;/p&gt;

&lt;p&gt;工具的意义不容否认，为此我还写过一篇&lt;a href=&quot;/computer/2015-12-20-tool-awareness.md&quot;&gt;《工具优先》&lt;/a&gt;。但工具的生命周期其实很短，从个人发展角度看，把过多时间投入到半衰期很短的事物上，并不划算。我入门时接触的是Pascal, BasicScript, ASP, IIS，不知道现在还有没有人用这些。很多程序员也赶时髦，本来写java的，golang流行了，python流行了，学！本来搞业务开发的，大数据火了，机器学习火了，学！打的旗号自然很鲜明：持续学习。几次之后，却怅然若失，貌似没一个是拿得出手的，不过是低水平重复，换个工具，继续做原来的事而已。充其量效率提高了，但效率型工作是可替代性最强的，被其它人替代，被机器替代。&lt;/p&gt;

&lt;p&gt;一颗上进爱学习的心，怎么就被辜负了呢？因为核心能力没有提升。人的能力好比电子围绕原子核旋转，大部分情况下处于巡航状态，在这过程中不断积蓄能量，始终向核心方向用力，就会跃迁到更高级轨道（这里指更靠近核心的轨道，实际电子是更远离核心的道）。“一万小时理论”和“10万行代码理论”只片面强调了量，如果没有聚焦核心，刻意练习，只能是低水平重复，甚至轨道降级。&lt;/p&gt;

&lt;p&gt;核心是抽象能力。这个世界的运行，有讲逻辑的，也有不讲逻辑的。程序员要处理的事是讲逻辑的那部分，因为你所依赖的计算机是讲逻辑的，要让它意气用事，感情用情，目前还很困难。通过抽象，我们识别并保留逻辑部分，抛弃其它内容，然后用计算机语言翻译、实现这个逻辑，进而解决问题。&lt;/p&gt;

&lt;p&gt;抽象这个词，本身就挺抽象的。到底什么是抽象？&lt;/p&gt;

&lt;p&gt;抽象是去除多余和细节。比如下面这个标志，一看就懂是座拱桥，但并没有显示拱桥的幅度、宽度和长度，因为这些数据对于你意识到这是一座拱桥并没有帮助。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2017.4/bridge.webp&quot; alt=&quot;&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;什么是多余信息，取决于目的。考虑地铁换乘图，其目的是告诉乘客该搭哪条线，在哪里换乘，所以保留了结构关系：站点的分布，以及线路的汇合点，但忽略了物理关系：站点的地理位置、相对距离，甚至扭曲了线路的方向。而如果是开车用的导航图，则必须保证比例尺和实际情况一致，方向也不能有差错，以免误导。&lt;/p&gt;

&lt;p&gt;抽象是建立模板或蓝图。不少公司里有邮件模板、文档模板、PPT模板、报销单模板，等等，它们规定好了结构、风格，并留出一个个空白，使用的时候填空就好。模板描述不变的内容，变量则延迟到使用场景中确定。Java编程时，经常要应用各种设计模式，其实质是通过抽象，固化不变的，封装变化的。比如，很常用的模板方法，流程和步骤无论什么场景都不变，已经在父类写好了，将具体场景的方法在父类里声明，但延迟到子类实现，封装的是方法实现。又比如，创建对象时，不常写new Tesla()，而是运用简单工厂模式，写成TeslaFactory.create()，因为对象的创建是易变的。与其在特斯拉多一个型号时，把所有new的地方都改一遍，不如在create方法里集中改。&lt;/p&gt;

&lt;p&gt;总之，抽象是应对变化，或者说寻找不变性的手段。既可以是不同事物之间的不变性，也可以是同一事物不同历史时间的不变性。虽然这里讲的是编程，但其应用远不止于此，看看贝索斯是怎么说的：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;我常被问一个问题：“在接下来的10年里，会有什么样的变化?”……但我很少被问到“在接下来的10年里，什么是不变的?”我认为第二个问题比第一个问题更加重要，因为你需要将你的战略建立在不变的事物上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有了上面的解释，便不难理解面向对象编程的原则：依赖接口而不是实现，依赖抽象类而不是具体类。它让代码的适应性更强，将来少改代码，少出错。同时，做一些参数设定时，更加有理有据，而不是trial and error。线程池大小怎么定？不用关心具体工作，分析阻塞和非阻塞的时间比例，应用Amdahl’s law搞定。队列大小怎么定？不管究竟放的是什么，确定你期望的排队时长，用Little’s law算下。&lt;/p&gt;

&lt;p&gt;世面上鲜有讲如何培养抽象思维的书，设计模式一类的，算搭一点边，但那是人家抽象的结果，而不是关于抽象的方法。也许我们在运用这些模式，或浏览一些工具和类库的代码过程中，偶有灵光一现，能从这些结果中反推作者的设计思想和精妙之处，毕竟它们也是抽象的结果。&lt;/p&gt;

&lt;p&gt;学习使用工具时，如果多个心眼，留意为什么有这个工具，做了什么取舍，工具于你将不仅是效率意义。做业务开发时，如果不是简单地翻译需求，多想一层，哪里易变，哪里不易变，如何隔离变化，再简单的开发，于你也有精进意义。&lt;/p&gt;

&lt;p&gt;抽象的层级可以有很多，能做多少层级的抽象是一种能力，而判断需要多少层级的抽象则是一种艺术。&lt;/p&gt;

&lt;p&gt;地上一个猴，树上七个猴，一共有几个猴？1+7=8，一共八个猴，用数字符号代替猴子，这是第一层。从对象到数字，大多数人对此熟悉到甚至没有意识到这是一种抽象。再进一层，则有些困难了，当初我理解“加速度”这个概念，就费功。不光是数量，还有结构的抽象，关系的抽象。当然，它们离我们都很远……&lt;/p&gt;

&lt;p&gt;可是，真的很远吗？当大部分人在关心如何写程序时，有人开始研究如何用程序写程序，当大部分人在关心如何看书、学习时，有人在教别人看书、学习。&lt;/p&gt;
</description>
        <pubDate>Sun, 26 Nov 2017 12:15:09 +0800</pubDate>
        <link>http://localhost:4000/computer/2017/11/26/core-skill-programmer.html</link>
        <guid isPermaLink="true">http://localhost:4000/computer/2017/11/26/core-skill-programmer.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>股价到底可不可预测</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/2017.2/stock-price.png&quot; alt=&quot;&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;昨晚ali太屌了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;微信上，老田没头没脑来这么一句。我的第一反应是去看股价，果然屌，一夜之间涨了超过13%。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;你买了吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;略不好意思地回答：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;20股…上市当天拿到现在…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我在股市大抵就是这样，赚钱的买得少，亏钱的买了一堆。辛酸血泪史，就不多提了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么会一天之内涨这么多？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;昨天开了个投资者大会&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我没有继续问，但心里埋着第二问：“为什么开个会，效果这么好？”&lt;/p&gt;

&lt;p&gt;最近，撸了个“时间交易所”，可以理解为股市的翻版，所以对这类问题稍微敏感了些。其实，对这个问题，大家多少都能回答一些：会上披露的收入增长远高于市场预期，推动股价上涨。&lt;/p&gt;

&lt;p&gt;足够简洁，但意尤未尽，有没有更底层，更系统的解释？凑巧翻出了积灰近两年的《经济学通识》，释疑解惑。&lt;/p&gt;

&lt;p&gt;要在时间流逝中发挥功能的商品或资源，叫着易耗品。易耗品的价格完全建立在人们对未来的主观估计上。&lt;/p&gt;

&lt;p&gt;股票是一种耐用品。股票的价格，是股票未来全部预期收益的现值。股票价格的变动，是人们对股票未来全部收益预期的变动。&lt;/p&gt;

&lt;p&gt;看看真正的高手是如何把握这一特点的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我决定买苹果以前主要想的是他们是不是还有可能成长，有多大的空间可以成长，威胁都可能来自什么地方，等等。我不去想他现在的股价和过去的股价。——段永平&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;人们现在愿意花多少钱买一只股票，取决于他们预计将来能从中获得多少。认识一变，价格就变。阿里的投资者大会，披露了有关未来事件的信息，改变了人们的认识，进而反应在股价上。&lt;/p&gt;

&lt;p&gt;既然 “人们对事物发展变化的认识变化”决定了价格的变动，那么，认识是如何变化的？&lt;/p&gt;

&lt;p&gt;很遗憾，认识的变化没有规律。&lt;/p&gt;

&lt;p&gt;在现实世界中，一切都按自然规律，有条不紊地进行着，但在观念世界中，人们在不断形成、比较、交换和修正对未来的预期。哲学家波普尔说：&lt;/p&gt;

&lt;p&gt;只要知识是增长的，那就必定有部分知识是我们明天才知道的。&lt;/p&gt;

&lt;p&gt;尽管事物的变化是有规律可循的，但新信息的内容和披露时间，是不可预知的。今天的你不知道明天的你会知道什么。有点绕口，美国前国防部长拉姆斯菲尔德在一次记者招待会上有有段rap式的描述:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are known knowns; there are things we know we know. We also know there are known unknowns; that is to say we know there are some things we do not know. But there are also unknown unknowns – the ones we don’t know we don’t know.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用过去的图表、曲线预测未来的趋势，是不靠谱的。于是，我默默地取关了github上预测比特币价格的repo。试图发现和掌握认识变化、信息批露的规律，也是徒劳的。怎么办？回归价值投资，老老实实研究公司的基本面，考察未来的盈利能力吧。&lt;/p&gt;

&lt;p&gt;如果还想动点“歪脑筋”呢？&lt;/p&gt;

&lt;p&gt;还是在人身上找机会吧，毕竟股市是人发明的，也是人在玩的，我们要战胜的不是客观规律，也不是股市规则，而是演对手戏的人。他人的弱点，正是你的机会。&lt;/p&gt;

&lt;p&gt;人常常是不理性的，但不理性的行为一旦被识别，就成了新的知识，就会被其他人理性地运用。对于信息披露，有人会“反应迟钝”，有人会“过度反应”，还有人会“惯性行动”。比如，大涨之后，常常出现回调，阿里这次也不例外，创新高之后，便稳步下跌。以及，大跌之后，常常过度下跌。这些是大概率重复出现的现象，于是就有人以此来牟利，而这种新认识马上又会反映到价格上。“在别人贪婪时恐惧，在别人恐惧时贪婪。”，说的大概就是这个理。只是贪婪和恐惧的程度，过度反应何时开始，惯性行动止于何处，都不是容易预测的。近年来，利用大数据技术分析 Twitter 用户的情绪预来测股价涨跌，就是一种尝试。&lt;/p&gt;

&lt;p&gt;alswl说，他新公司有同事在尝试追财报买股票，赌财报发布后股价会上涨。脑筋转得挺快，就不知道效果如何了。&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Jun 2017 12:15:09 +0800</pubDate>
        <link>http://localhost:4000/thinking/2017/06/18/stock-price.html</link>
        <guid isPermaLink="true">http://localhost:4000/thinking/2017/06/18/stock-price.html</guid>
        
        
        <category>thinking</category>
        
      </item>
    
      <item>
        <title>不为人知的阅读模型</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/201612/reading-model.jpeg&quot; alt=&quot;&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上周讲了读书的效率问题，这周再说说质量问题。&lt;/p&gt;

&lt;h4 id=&quot;价值衰减模型&quot;&gt;价值衰减模型&lt;/h4&gt;
&lt;p&gt;永泽有个原则：“对死后不足三十年的作家，原则上是不屑一顾的”，意思是没有经受住时间考验的作品，不值一看。这个原则可以拓展为，不仅看“过去”，也要看“未来”：书中所讲的内容，在未来多少年内依然成立？时间越短，越不值得去读。毕竟，精力有限，我希望回报能长久一点。&lt;/p&gt;

&lt;p&gt;任何信息，包括书，都有保值期。&lt;/p&gt;

&lt;p&gt;只是这个保值期，不像食品的保质期一样有明确的时间点。它甚至不是一个“二值”化的阶跃函数，而是一个连续变化的曲线。&lt;/p&gt;

&lt;p&gt;有些书，价值是个常量，不随时间的变化而变化。比如数学，即使地球消失了，它依然有价值。有些书，还没写完，价值就开始衰减。比如，讲林丹出轨之类的八卦杂志。&lt;/p&gt;

&lt;p&gt;基础模型确定了，接下来要细化。哪些书是常量型的，哪些是衰减型的，衰减的速度是多少。明确这些，就不难决择了。不知道你有没有注意到，这个模型不光是适用在选书这一个场景，判断一件事值不值得做，值得投入多少精力，都可以用这个“价值衰减模型”。从一个场景、案例、细节中发现规律，总结、归纳，抽象出模型，并把它应用到其它场景，这叫迁移。理解力，决定了你能吸收多少，而迁移力，决定了你能运用多少。&lt;/p&gt;

&lt;p&gt;上周，在公司的读书分享会上介绍了《Math Better Explained》一书，着重讲了自然底数e。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;e is the base amount of growth shared by all continually growing processes&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所有持续增长（其实也包括减少）的过程，都有共同的基数e。类似复利、放射性元素的衰减……e像一根线把这些原本散落的，随时可能脱落的点串了起来。我的知识架构上又多了一个钩子，可以连接原本不通的节点，又可以为以后挂载新节点做铺垫。这是我十分珍视的东西，一看到钩子型知识，就两眼放光。&lt;/p&gt;

&lt;h4 id=&quot;收益函数模型&quot;&gt;收益函数模型&lt;/h4&gt;
&lt;p&gt;价值衰减慢的，不一定对你就是好书。涉及个人时，在“价值衰减模型”基础上还要看它能给你带来多少收益。&lt;/p&gt;

&lt;p&gt;给团队贴过一篇博客：《The Immutability of Math and How Almost Everything Else Will Pass》，很让人触动的博客，它让我真正意识到了知识是存在保质期的。而上面对e的理解又提醒我，知识在保质期内应该是持续衰减的过程。你在不同地方，不同时间看的书会不经意间碰撞，融合，产生新的见解。这种碰撞是不可预期的，只有事后回顾才能发现，就像乔布斯说的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看书的收益正比于数量的平方。A看了5本，B 4本，C 3本。虽然绝对数量上A少于B和C之和，但A的收益等于二者之和。当然，前提是他们联想、撮合知识点的能力是一样的。&lt;/p&gt;

&lt;p&gt;为什么是平方？这是我臆想的，没法论证。你也可以说成是立方，阶乘。当然，不幸的话，开方也是有可能的。这不是重点，我重点强调的是，这是个非线性的关系，影响收益函数的因素有：读书量，以及所读内容之间产生化学反应的量级。我觉得大部分人的收益要好于线性函数，但又不至于好到夸张，所以用了平方。我称之为“收益函数模型”。&lt;/p&gt;

&lt;p&gt;那么，有什么启发？首先，要改变单纯追求数量的观念，多不等于好；其次，要选择那些跟你已有知识体系能产生反应的书籍。一本书，看完很长时间后，内心依然平静如水，甚至快过了保值期，还激不起半点涟漪，无疑就是一次失败的阅读。如果你也写作，看完后有没有写点什么的冲动，也是一个不错的验证方式。&lt;/p&gt;

&lt;h4 id=&quot;好莱坞大片模型&quot;&gt;好莱坞大片模型&lt;/h4&gt;
&lt;p&gt;现实生活中和人发生冲突的可能性很小，我把它转移到了书上：看书最好要能制造冲突。你带观点时，就和纸面、屏幕后面的作者来一场辩论；不带观点时，就当捣蛋鬼专门给老师难堪。不论书中内容如何，刻意制造冲突，看书的过程就是一部跌宕起伏的大戏。一会儿作者冲着你骂“傻X，还用这种过时的方式看待世界！”，一会儿你还道：“我早知道了，啰里吧嗦！”，扳回一局。这样看书确实挺累，有时候为了搞懂或者反驳对方一个论点，百度谷歌齐上阵，翻箱倒柜，扯出好多资料。但你是带情绪的，带感情的，印象深刻，以后发生化学反应的概率就大了。&lt;/p&gt;

&lt;p&gt;当然，你也可以用苏格拉底式辩论法——提问，心平气和地提问，直到对方意识到他错了。不过这有点难，毕竟苏格拉底不是想学就能学的。&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Dec 2016 12:15:09 +0800</pubDate>
        <link>http://localhost:4000/reading/2016/12/07/on-reading.html</link>
        <guid isPermaLink="true">http://localhost:4000/reading/2016/12/07/on-reading.html</guid>
        
        
        <category>reading</category>
        
      </item>
    
  </channel>
</rss>
