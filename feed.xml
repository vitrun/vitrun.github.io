<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Food for Thought Expected</title>
    <description>while [ 'alive' ]; do think &amp;&amp; act | tee blog; done</description>
    <link>https://blog.yuzhi.run/</link>
    <atom:link href="https://blog.yuzhi.run/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 24 Jul 2020 14:05:19 +0800</pubDate>
    <lastBuildDate>Fri, 24 Jul 2020 14:05:19 +0800</lastBuildDate>
    <generator>Jekyll v3.8.7</generator>
    
      <item>
        <title>monkey patch in go</title>
        <description>&lt;h2 id=&quot;什么是monkey-patch&quot;&gt;什么是monkey patch&lt;/h2&gt;

&lt;p&gt;早前的一个python项目遇到性能瓶颈，试图用对标准库做&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;monkey
patch&lt;/code&gt;，在不改源码的情况下，用&lt;a href=&quot;http://www.gevent.org/api/gevent.monkey.html&quot;&gt;gevent&lt;/a&gt;让标准库用上非阻塞IO。
留下的印象是以为在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt;等动态语言里才有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;monkey patch&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;偶然看到&lt;a href=&quot;https://github.com/bouk/monkey&quot;&gt;bouk/monkey&lt;/a&gt;，才发现，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go&lt;/code&gt;语言也可以实现。好奇之下，研究了它的原理。作者有个&lt;a href=&quot;https://bou.ke/blog/monkey-patching-in-go/&quot;&gt;博客&lt;/a&gt;，讲得很好，但缺了很多细节和过程。于是，从问题源头出发，自己理一遍，收益良多：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;程序的编译、连接与执行&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go&lt;/code&gt;工具&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compile&lt;/code&gt;与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;objdump&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go&lt;/code&gt;函数值实现&lt;/li&gt;
  &lt;li&gt;plan9汇编&lt;/li&gt;
  &lt;li&gt;X86指令、寄存器&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;魔法&quot;&gt;魔法&lt;/h2&gt;
&lt;p&gt;简单来说，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;monkey patch&lt;/code&gt;，以下代码将输出”2”而不是”1”：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不难看出，魔法都藏在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replace&lt;/code&gt;函数里：需要修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;函数，使其不执行自己的函数体，而是跳转到函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;为了讲清楚如何实现，得先铺垫几点背景知识。&lt;/p&gt;

&lt;h2 id=&quot;go与汇编&quot;&gt;go与汇编&lt;/h2&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go&lt;/code&gt;项目里使用汇编是件很容易的事。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go&lt;/code&gt;代码&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func.go&lt;/code&gt;里只声明函数：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;汇编代码&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func.s&lt;/code&gt;里，实现两函数，这里，我们让&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;函数跳转到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;#include &quot;textflag.h&quot;

TEXT ·a(SB), NOSPLIT, $0-8
  JMP ·b(SB)

TEXT ·b(SB), NOSPLIT, $0-8
  MOVQ $2, ret1+0(FP)
  RET
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func.go&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func.s&lt;/code&gt;放到同一目录，然后执行：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GO111MODULE=&quot;off&quot;; go build -o func &amp;amp;&amp;amp;
./func&lt;/code&gt;。这段代码定义了两个函数，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;函数直接跳转到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;函数，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;返回整数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;。至此，没什么大不了，手动实现跳转而已。&lt;/p&gt;

&lt;p&gt;关于汇编的语法，不是本文的重点，可以参考文后链接。&lt;/p&gt;

&lt;h2 id=&quot;go的函数值类型&quot;&gt;go的函数值类型&lt;/h2&gt;

&lt;p&gt;手动跳转显然不够，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replace(f, g)&lt;/code&gt;的职责就动态改变函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;的代码，分两步：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;取得函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;的地址&lt;/li&gt;
  &lt;li&gt;重写&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;，使其跳转到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要指出的是，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replace&lt;/code&gt;的入参&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;或&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;很容易被误解为函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;或&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;的指针，但其实它们是指针的指针。这点可以通过反编译来验证，保存下面代码到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;funcaddr.go&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;unsafe&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0x%x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; go build funcaddr.go &amp;amp;&amp;amp; ./funcaddr&lt;/code&gt;得到：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x109adc0&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;再执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go tool objdump -S funcaddr&lt;/code&gt;，搜索这个地址，发现确实是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;函数的地址：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;TEXT main.a(SB) funcaddr.go
func a() int { return 1 }
  0x109adc0             48c744240801000000      MOVQ $0x1, 0x8(SP)
  0x109adc9             c3                      RET

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok，通过函数值&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;可以拿到函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;的地址了。为什么要拿到地址呢？&lt;/p&gt;

&lt;h2 id=&quot;在运行时改写函数&quot;&gt;在运行时改写函数&lt;/h2&gt;

&lt;p&gt;函数体本质是一段字符串，知道开始地址后，从那里开始写入表示新逻辑的字符串即可实现覆盖。随之而来的问题是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新逻辑的字符串是什么？&lt;/li&gt;
  &lt;li&gt;如何知道覆盖的范围？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为新的字符串要能直接被机器运行，所以它必须是机器码。把汇编翻译成机器码，并不是件容易的事，同一段汇编在不同平台得到的机器不尽相同。如果想手动翻译，可参考文后链接。&lt;/p&gt;

&lt;p&gt;我用了一个取巧的方式，反翻译上面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go tool objdump -S
func&lt;/code&gt;，找到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.a&lt;/code&gt;的定义：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TEXT main.a(SB) func.s
  0x1054e70         e90b000000           JMP main.b(SB)
  //...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e90b000000&lt;/code&gt;就是跳转到函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;的机器码。终于可以来实现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replace&lt;/code&gt;函数了：&lt;/p&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rawMemoryAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0xFF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0xe9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x0b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;funcLocation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;window&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rawMemoryAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;funcLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;逻辑实现了，但这段代码是无法运行的。因为加载的二进制文件&lt;a href=&quot;https://en.wikipedia.org/wiki/Segmentation_fault#Writing_to_read-only_memory&quot;&gt;默认是无法修改的&lt;/a&gt;，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy&lt;/code&gt;这行将报错。我们用系统调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mprotect&lt;/code&gt;来关闭这一保护机制，得到可用的代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;//go:noinline&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;syscall&quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;unsafe&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rawMemoryAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0xFF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getPage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0xFFFFFF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Getpagesize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Getpagesize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assembleJump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0xe9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x0b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assembleJump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;functionLocation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;window&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rawMemoryAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;functionLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getPage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;functionLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mprotect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PROT_READ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PROT_WRITE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PROT_EXEC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  
  &lt;span class=&quot;nb&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;现在可以直接执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go run
func.go&lt;/code&gt;，因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func.s&lt;/code&gt;只是用于帮助理解，现在不再需要了。
注意&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;//go:noinine&lt;/code&gt;这行，用于关闭函数内联，这样才能支持改写。&lt;/p&gt;

&lt;p&gt;眼尖的读者可能发现了，这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replace&lt;/code&gt;不够通用，还是写死了跳转到函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;而不是指定的函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;，实际上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;参数根本没用上！
为了通用，我们改造&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assembleJump&lt;/code&gt;，让跳转的机器码使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;所指向的地址：&lt;/p&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assembleJump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;funcVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;m&quot;&gt;0x48&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0xC7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0xC2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;funcVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;funcVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;funcVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;funcVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// MOV rdx, funcVal&lt;/span&gt;
    &lt;span class=&quot;m&quot;&gt;0xFF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// JMP rdx&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里不是直接&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmp&lt;/code&gt;到函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;，而是先把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;的地址存到寄存器&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdx&lt;/code&gt;，再&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmp&lt;/code&gt;到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdx&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;用这个通用的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assembleJump&lt;/code&gt;替换上面返回固定值的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assembleJump&lt;/code&gt;，大功造成。&lt;/p&gt;

&lt;h2 id=&quot;monkey-patch的应用&quot;&gt;monkey patch的应用&lt;/h2&gt;

&lt;p&gt;显然，这是一种hack，不能用于生产环境。随着go版本的迭代，没准不久的将来就失效了。如果仔细观察，会发现我们手写的汇编或者机器码，比&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go&lt;/code&gt;编译得到的少了些含有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FUNCDATA&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PCDATA&lt;/code&gt;字眼的内容：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  0x0000 00000 (func.go:9) FUNCDATA        $0,
gclocals·33cdeccccebe80329f1fdbee7f5874cb(
SB)
  0x0000 00000 (func.go:9) FUNCDATA        $1,
gclocals·33cdeccccebe80329f1fdbee7f5874cb(
SB)
  0x0000 00000 (func.go:9) FUNCDATA        $2,
gclocals·33cdeccccebe80329f1fdbee7f5874cb(
SB)
  0x0000 00000 (func.go:9) PCDATA  $0, $0
  0x0000 00000 (func.go:9) PCDATA  $1, $0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PCDATA&lt;/code&gt;把程序计数器和代码行号对应起来，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FUNCDATA&lt;/code&gt;则是为垃圾回收服务的，详见&lt;a href=&quot;https://www.altoros.com/blog/golang-internals-part-4-object-files-and-function-metadata/&quot;&gt;Object
Files and Function
Metadata&lt;/a&gt;。缺少它们，相应功能就有缺陷。&lt;/p&gt;

&lt;p&gt;难道，只能用于装逼了？&lt;/p&gt;

&lt;p&gt;不，有一个场合正是用武之地：测试。将它用于打桩，让用户在单元测试中低成本的完成mock。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go&lt;/code&gt;的各种mock工具都只能对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;类型做mock。虽然我们一直提倡依赖倒置，现实中，还是有很多代码直接依赖了具体实现，给mock带来不必要的麻烦。&lt;/p&gt;

&lt;p&gt;正好，黑魔法般的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;monkey
patch&lt;/code&gt;来搭救了。使用封装好的&lt;a href=&quot;https://github.com/bouk/monkey&quot;&gt;monkey&lt;/a&gt;，可以非常简单地实现对非&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;依赖的mock。&lt;/p&gt;

&lt;p&gt;举个例子，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RpcClient&lt;/code&gt;是个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct&lt;/code&gt;，代表外部rpc调用：&lt;/p&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rpc&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RpcClient&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RpcClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SayHello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// call remote endpoint&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello world&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在测试时mock这个rpc调用，返回指定内容：&lt;/p&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rpc&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;bou.ke/monkey&quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;github.com/stretchr/testify/assert&quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;reflect&quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;testing&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TestSayHello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RpcClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;fakeRpc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;monkey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PatchInstanceMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reflect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TypeOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;SayHello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpcClient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RpcClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hi five&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fakeRpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unpatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  
  &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SayHello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Equal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hi five&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行测试时，需要关闭内联：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go test -gcflags=-l&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.mit.edu/afs.new/sipb/project/golang/doc/asm.html&quot;&gt;A Quick Guide to Go’s
Assembler&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/teh-cmc/go-internals/blob/master/chapter1_assembly_primer/README.md#a-word-about-goroutines-stacks-and-splits&quot;&gt;A Primer on Go
Assembly&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.systutorials.com/beginners-guide-x86-64-instruction-encoding/&quot;&gt;A Beginners’ Guide to x86-64 Instruction
Encoding&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.osdev.org/X86-64_Instruction_Encoding&quot;&gt;X86-64 Instruction
Encoding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 20 Jun 2020 12:15:09 +0800</pubDate>
        <link>https://blog.yuzhi.run/computer/2020/06/20/go-monkey-patch.html</link>
        <guid isPermaLink="true">https://blog.yuzhi.run/computer/2020/06/20/go-monkey-patch.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>Go性能诊断工具pprof入门</title>
        <description>&lt;p&gt;测试环境一个api应用突然cpu飙高，稳定在98%……&lt;/p&gt;

&lt;p&gt;第一反应是jstack看下是不是代码里有死循环了？然而这是go不是java，只能在go的生态里重新寻找类似工具。&lt;/p&gt;

&lt;p&gt;切换语言时，除了改变写代码的语言，有必要&lt;strong&gt;熟悉维护应用、定位问题的工具链&lt;/strong&gt;。这里简单介绍go pprof的使用，以求需要时不必临时google，能以最快速度开始定位问题。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;pprof is a tool for visualization and analysis of profiling data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装请执行：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go get -u github.com/google/pprof&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;cpu-profile&quot;&gt;cpu profile&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;找到容器的IP和debug端口对应的访问端口。&lt;/li&gt;
  &lt;li&gt;执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go tool pprof -http=:6061 http://$ip:$port/debug/pprof/profile&lt;/code&gt;
需要一段时间来采样，耐心等待下。采样结束后，将自动在浏览器中打开可视化分析页面。不加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-http=:6061&lt;/code&gt;时将在终端使用命令行方式交互。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;采样数据默认放到~/pprof/目录下，可通过以下命令直接指定文件进行分析。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go tool pprof -http=:6061 ~/pprof/xxx.pb.gz&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;top-view&quot;&gt;Top view&lt;/h4&gt;
&lt;p&gt;效果如下：
&lt;img src=&quot;/img/202005/ppro-1.jpg&quot; alt=&quot;IMAGE&quot; /&gt;&lt;/p&gt;

&lt;p&gt;重点是理解&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flat&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sum&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cum&lt;/code&gt;三个指标。对于函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;                             &lt;span class=&quot;c&quot;&gt;// step1 takes 1s&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;                             &lt;span class=&quot;c&quot;&gt;// step2 takes 1s&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;something&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;directly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// step3 takes 3s&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;                             &lt;span class=&quot;c&quot;&gt;// step4 takes 1s&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flat&lt;/code&gt;是step3的耗时，即3s。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cum&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt;的整体耗时，包括子函数和直接指令的耗时，即6s。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum&lt;/code&gt;是截至当前行的累计耗时。&lt;/p&gt;

&lt;p&gt;上图的例子是调用了一次api的效果（服务器没有其它请求），耗时27s，大部分时间花在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go-polaris&lt;/code&gt;这个库内，无论哪个指标出发，都很显然要重点看看&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanAttrEql&lt;/code&gt;函数(结论是该函数死循环了)。&lt;/p&gt;

&lt;h4 id=&quot;graph-view&quot;&gt;Graph view&lt;/h4&gt;
&lt;p&gt;按调用层级从上到下显示调用图，需要安装&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;graphviz&lt;/code&gt;：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew install graphviz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;括号内的数值同top view。框的大小和箭头的粗细会随着耗时和增加而变大，比较直观。&lt;/p&gt;

&lt;h4 id=&quot;flame-graph&quot;&gt;Flame graph&lt;/h4&gt;
&lt;p&gt;倒置的火焰图，更常见的形式，也很直观。不展开，可参考&lt;a href=&quot;https://www.ruanyifeng.com/blog/2017/09/flame-graph.html&quot;&gt;如何读懂火焰图？&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;memory-profile&quot;&gt;memory profile&lt;/h3&gt;
&lt;p&gt;执行:
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go tool pprof -http=:6061 http://$ip:$port/debug/pprof/heap&lt;/code&gt;
几个view的解读同cpu profile，不再重复。需要指出的是内存分析比较关心的两个指标，通过在命令中添加以下参数可以获得：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;-inuse_space&lt;/strong&gt;：分析程序&lt;strong&gt;常驻&lt;/strong&gt;内存的占用情况，数值大说明程序当前时刻内存占用较多。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;-alloc_objects&lt;/strong&gt;：分析内存的&lt;strong&gt;临时分配&lt;/strong&gt;情况，记录程序累计分配的对象，数值大说明有很多对象经常需要临时分配，然后在gc的时候又被释放，对gc的影响比较大。gcPause问题比较严重的时候可以关注这个指标。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;其它profile&quot;&gt;其它profile&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cpu&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memory&lt;/code&gt;是常用的的profile类型，值得事先花点时间掌握，其余的可在碰到需求时临时查阅文档。&lt;/p&gt;

&lt;p&gt;访问&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://$ip:$port/debug/pprof/&lt;/code&gt;得到整体可供profile的选项：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;cpu（CPU Profiling）: /debug/pprof/profile，默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件&lt;/li&gt;
  &lt;li&gt;block（Block Profiling）：/debug/pprof/block，查看导致阻塞同步的堆栈跟踪&lt;/li&gt;
  &lt;li&gt;goroutine：/debug/pprof/goroutine，查看当前所有运行的 goroutines 堆栈跟踪&lt;/li&gt;
  &lt;li&gt;heap（Memory Profiling）: /debug/pprof/heap，查看活动对象的内存分配情况&lt;/li&gt;
  &lt;li&gt;mutex（Mutex Profiling）：/debug/pprof/mutex，查看导致互斥锁的竞争持有者的堆栈跟踪&lt;/li&gt;
  &lt;li&gt;threadcreate：/debug/pprof/threadcreate，查看创建新OS线程的堆栈跟踪&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;延伸讨论&quot;&gt;延伸讨论&lt;/h3&gt;
&lt;h4 id=&quot;启用方式&quot;&gt;启用方式&lt;/h4&gt;
&lt;p&gt;pprof主要有三种数据获取方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;runtime/pprof: 手动调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runtime.StartCPUProfile&lt;/code&gt;或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runtime.StopCPUProfile&lt;/code&gt;等 API来生成和写入采样文件&lt;/li&gt;
  &lt;li&gt;net/http/pprof: 通过 http 服务获取Profile采样文件，简单易用，适用于对应用程序的整体监控。通过 runtime/pprof 实现。如果在自己的程序中需要支持pprof，推荐此方式，只需要引入这个依赖即可：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import _ &quot;net/http/pprof&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;go test: 通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go test -bench . -cpuprofile prof.cpu&lt;/code&gt;生成采样文件 适用对函数进行针对性测试&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;原理&quot;&gt;原理&lt;/h4&gt;
&lt;p&gt;没有正式的文档，参考golang团队成员ian lance taylor的一段回答：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Is it true that pprof is a stop-the-world sampler? Does it periodically stop
the program being profiled to collect information?&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;No.&lt;/p&gt;

  &lt;p&gt;Is pprof a statistical/stochastic profile?&lt;/p&gt;

  &lt;p&gt;Yes.&lt;/p&gt;

  &lt;blockquote&gt;
    &lt;p&gt;Is it also an event based profiler?&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;Yes.&lt;/p&gt;

  &lt;blockquote&gt;
    &lt;p&gt;I know it doesn’t run at the kernal level, but where in the OS does pprof
profile?&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;As you say, the net/http/pprof package is basically a wrapper around
the runtime/pprof package.&lt;/p&gt;

  &lt;p&gt;For CPU profiling, runtime/pprof works by periodically interrupting
the program.  On Unix-like systems, this is done using setitimer to
send a periodic SIGPROF signal.  When this signal arrive, the
goroutine that receives it stores a stack trace.  This very briefly
stops the goroutine being profiled, but it doesn’t affect the rest of
the program.&lt;/p&gt;

  &lt;p&gt;For heap profiling, the memory allocator tracks the number of
allocations it has done, and periodically records a stack trace.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;overhead&quot;&gt;overhead&lt;/h4&gt;
&lt;p&gt;凡事都有成本，采样时的成本(只有访问debug profile时才会引入该成本，只是引入依赖不会有成本)：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;pprof is safe to use in production. We target an additional 5% overhead for CPU and heap allocation profiling&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另一google员工的描述：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;At Google, we continuously profile Go production services and it is safe to do so.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;单纯讨论这一成本是高低意义不大，这里涉及一个更大的话题：&lt;a href=&quot;https://medium.com/google-cloud/continuous-profiling-of-go-programs-96d4416af77b&quot;&gt;Continuous Profiling of Go programs&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;参考文档&quot;&gt;参考文档&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/google/pprof/blob/master/doc/README.md&quot;&gt;Google/pprof readme&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://golang.org/pkg/net/http/pprof/&quot;&gt;Package pprof&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/32571396/pprof-and-golang-how-to-interpret-a-results&quot;&gt;Pprof and golang - how to interpret a results
&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bytedance.feishu.cn/wiki/wikcnRO5EewsntuRMbB4DPzescf#&quot;&gt;Go pprof 业务中实战&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://groups.google.com/forum/#!topic/golang-nuts/PiFa55aX7Ds&quot;&gt;How does pprof work under the hood&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 30 May 2020 12:15:09 +0800</pubDate>
        <link>https://blog.yuzhi.run/computer/2020/05/30/pprof-tutorial.html</link>
        <guid isPermaLink="true">https://blog.yuzhi.run/computer/2020/05/30/pprof-tutorial.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>Go项目单元测试实践</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;单测本身不是目的，更根本地，要提升工程的可维护性。&lt;/p&gt;

&lt;p&gt;为什么随着时间的推移，工程越来越难维护？因为工程的复杂度的增速快于我们治理复杂度的能力的增速。治理复杂度的能力落地了就是工程的可维护性。&lt;/p&gt;

&lt;p&gt;用线性的手段去治理指数的问题，只在初期可行。长期必须要有一个比问题曲线更陡的能力曲线。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/202004/go-ut-1.jpg&quot; alt=&quot;IMAGE&quot; /&gt;&lt;/p&gt;

&lt;p&gt;影响工程复杂度的因素：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;业务的本质复杂性&lt;/li&gt;
  &lt;li&gt;互联网高人员流动性&lt;/li&gt;
  &lt;li&gt;文档永远缺失或滞后&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;治理复杂度的能力&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;设计能力&lt;/li&gt;
  &lt;li&gt;测试能力&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文从测试角度出发做一点探讨。首先澄清概念，这里的“测试”专指研发人员自行开展的测试工作，不包括QA同学的工作。&lt;/p&gt;

&lt;p&gt;可能涉及单元、集成、功能测试，用下图说明：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/202004/go-ut-2.jpg&quot; alt=&quot;IMAGE&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;测试的意义&quot;&gt;测试的意义&lt;/h2&gt;
&lt;p&gt;常见的说法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;等项目提测后再补些单测。其心理：
    &lt;ul&gt;
      &lt;li&gt;不知有没有意义，tl要求，没办法&lt;/li&gt;
      &lt;li&gt;有意义，为了方便后续人员维护&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;事后补单测，好比把到女神了，依然热度不减当初，天天嘘寒问暖。是有这样的人，但你是吗？&lt;/p&gt;

&lt;p&gt;另一种认识：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;帮助本人开发现在的功能。&lt;strong&gt;本人&lt;/strong&gt;！&lt;strong&gt;现在&lt;/strong&gt;！
在没有护栏的高速路狂奔，开得越快，死得越快。
&lt;img src=&quot;/img/202004/go-ut-3.jpg&quot; alt=&quot;IMAGE&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;帮助提高项目的长度维护性。顺便！
在&lt;strong&gt;高人员流动&lt;/strong&gt;的情境下实现工程的&lt;strong&gt;长期可维护性&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;靠员工传承 ✕&lt;/li&gt;
      &lt;li&gt;靠文档传承 ✕&lt;/li&gt;
      &lt;li&gt;自解释工程 √&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;test as a doc&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;可用的测试&quot;&gt;可用的测试&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;低成本&lt;/strong&gt;地实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可重复运行&lt;/li&gt;
  &lt;li&gt;可自动运行&lt;/li&gt;
  &lt;li&gt;不依赖外部环境&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;即，测试本身的scalability&lt;/p&gt;

&lt;p&gt;对比几种测试做法：&lt;/p&gt;

&lt;h4 id=&quot;流程1&quot;&gt;流程1:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;为case1在db造数据 (每次3m)&lt;/li&gt;
  &lt;li&gt;本地启用应用（改配置连本地服务) (每次2m)&lt;/li&gt;
  &lt;li&gt;在postman配置，为case1调api (若能长期保存psotman配置，则每次1m，否则每次5m）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;流程2&quot;&gt;流程2:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;为case1在db造数据 (每次3m)&lt;/li&gt;
  &lt;li&gt;写测试代码 (首次10min，以后0)&lt;/li&gt;
  &lt;li&gt;运行测试代码 (每次0.1m)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;流程3&quot;&gt;流程3:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;为case1在代码中靠数据 (首次6m，以后0)&lt;/li&gt;
  &lt;li&gt;写测试代码 (首次10min，以后0)&lt;/li&gt;
  &lt;li&gt;运行测试代码 (每次0.1m)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;长期耗时对比：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;流程1：(3+2)&lt;em&gt;n + 5 + 1&lt;/em&gt;(n-1) = 6n+4&lt;/li&gt;
  &lt;li&gt;流程2：3&lt;em&gt;n + 10 + 0.1&lt;/em&gt;n = 3.1n+10&lt;/li&gt;
  &lt;li&gt;流程3：6+10+0.1n = 0.1n+16&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/202004/go-ut-4.jpg&quot; alt=&quot;IMAGE&quot; /&gt;&lt;/p&gt;

&lt;p&gt;流程1和2都是非scalable的做法，问题分析：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;流程1，依赖了外部环境，不可重复、无法自动化&lt;/li&gt;
  &lt;li&gt;流程2，依赖了外部环境，不可重复，可以自动化&lt;/li&gt;
  &lt;li&gt;流程3，不依赖外部环境，可以重复，可以自动化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以为点点postman、连mysql造条数据是图省事，诸不知这是更费事的做法。一个短期、一个长期，本质上都是“偷懒”，省点时间多看看窗外的风景、少掉几根头发。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Less is exponentially more —— Rob Pike&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果认同上述观点，接下来的内容其实不看也没啥损失。因为你总会想出各种手段去“偷懒”的，具体的手段反而关系不大了。换言之，以下方式随时可能被更先进、更scalable的方式替代。&lt;/p&gt;

&lt;h2 id=&quot;工程可测性&quot;&gt;工程可测性&lt;/h2&gt;

&lt;h3 id=&quot;遵守控制反转原则&quot;&gt;遵守控制反转原则&lt;/h3&gt;

&lt;p&gt;并不是所有代码都是可测试的。谈具体测试做法前，得先保证代码的可测性。道理上是极其简单的，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SOLID&lt;/code&gt;原则中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Any higher classes should always depend upon the abstraction of the class rather than the detail. –&lt;strong&gt;Dependency Inversion Principle&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但实践起来并不那么容易。
比如，业务代码中很常见的repo调用dal的写法：&lt;/p&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RepositoryImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;userDO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;convert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UserModel2DO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;dal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userDO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;比如，调用rpc的写法：&lt;/p&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// 调用rpc：&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;thirdcall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProduceServiceClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QueryTaskPackPage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pageTaskPackRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// ProduceServiceClient定义：&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;kc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kitc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KitcClient&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;毫无违和感，却是违背&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt;的，进而限制可测性。&lt;/p&gt;

&lt;p&gt;因为抽象是可变的，实现是固定的。依赖抽象使得测试过程中剥离无关部分（可能是其它系统、也可能是本系统的其它代码）成为可能。而测试，只应测试目标代码，既不应依赖另一个系统、模块的输入，也不应输出到另一个系统、模块，这是“不依赖外部环境”的双重含义。（从这个意义上说，测试的过程应践行函数式编程的理念：pure、immutable、no side effect。）&lt;/p&gt;

&lt;p&gt;就go语言而言，唯一的抽象工具就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;了。当依赖&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;时，可以在测试时用内存实现的db替换外部的mysql；用mock的rpc客户端替换真实的rpc调用。&lt;/p&gt;

&lt;h3 id=&quot;尽量避免全局变量&quot;&gt;尽量避免全局变量&lt;/h3&gt;

&lt;p&gt;一时全局一时爽，一直全局会很惨！&lt;/p&gt;

&lt;p&gt;散落在各处的全局变量引用，让人无法快速分析出外部依赖。本质上全局变量是固定的实现，绑定全局变量同样使得剥离依赖变量困难。&lt;/p&gt;

&lt;p&gt;建议：总是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct&lt;/code&gt;定义里声明清楚外部依赖，哪怕只是一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;config&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TaskPackServiceImpl&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;MaterialService&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;MaterialService&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;TaskService&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;TaskService&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;UserService&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;UserService&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MatrixClientImpl&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MatrixConfig&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有个例外情况。构造器初始化传参的方式过于简单，复杂项目下，在我们没有依赖注入工具的情况下，会让单例生成变得很繁琐。如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TaskPackService&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TaskService&lt;/code&gt;互相依赖，无法直接构造出来。如果严格执行上述建议，相当于人工实现依赖注入。所有单例都先使用无参数构造器&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt;出来，然后再遍历依赖图，一个个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;在引入依赖注入工具之前，这种耦合严重的场景可以直接引用全局变量，其余场景（占多数，毕竟是微服务）仍坚持该建议。&lt;/p&gt;

&lt;h2 id=&quot;方法与实操&quot;&gt;方法与实操&lt;/h2&gt;

&lt;p&gt;权衡投入产出，推荐对服务的serivce层做测试。服务的handler层和api暂不推荐。以service的公有方法为单位编写若干测试用例。&lt;/p&gt;

&lt;p&gt;推荐两种实践：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对复杂的service方法做单元测试，即把该方法的外部依赖全部mock掉，包括其它service，和自己dal层。&lt;/li&gt;
  &lt;li&gt;复杂度一般的service方法，直接做集成测试，即不mock其它的其它service，不mock自己的dal层。但mock掉外部依赖：rpc、中间件的调用，等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总得来说：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mock&lt;/code&gt;，只是结合具体场景的手段不尽相同。&lt;/p&gt;

&lt;h4 id=&quot;场景1数据库调用&quot;&gt;场景1，数据库调用&lt;/h4&gt;

&lt;p&gt;有两种路线：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1，直接把dal层mock掉&lt;/li&gt;
  &lt;li&gt;2，dal层真实，但db被mock&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;建议走路线2，因为我们的业务往往&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sql&lt;/code&gt;的正确性是非常关键的，有些功能甚至就是些&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crud&lt;/code&gt;，路线1把dal层都mock掉了，发现问题的可能性大大降低了。&lt;/p&gt;

&lt;p&gt;用内存数据库替代真实数据库（这也是一种mock）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;dao依赖抽象的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DBManager&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;提供&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DBManager&lt;/code&gt;的两个实现&lt;/li&gt;
  &lt;li&gt;在init内提供选择（只在这里有区别，其余代码完全一样）&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// 抽象的db协议&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DBManager&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;WithDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;GetDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gorm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DB&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;TransactionWithResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fc&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fc&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 测试用的db实现&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DBManagerFake&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 生产用的db实现&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DBManagerReal&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// dal包的Init方法提供两种Init:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;initRealDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// 外部mysql&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;EMDBManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DBManagerReal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;  
	&lt;span class=&quot;n&quot;&gt;initDAOs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InitTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;initFakeDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// 内存sqlite&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;EMDBManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DBManagerFake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;initDAOs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// XXX_test.go文件里使用InitTest：&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TestAuditPassAction_Transfer_DoublePass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;dal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InitTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;	

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;场景2外部调用&quot;&gt;场景2，外部调用&lt;/h4&gt;
&lt;p&gt;数据库场景里代码在我们掌握范围内，像redis、rpc之类的（统称外部调用）客户端代码都是提供好的，像我司的kitool生成的客户端代码就是一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type Client struct&lt;/code&gt;，并没有提供&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;，怎么办？&lt;/p&gt;

&lt;p&gt;我们自己写个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;，再引用预生成的代码实现该&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;。实际使用时，不直接用预生成的代码，而是通过依赖该&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crowd&lt;/code&gt;项目和题库的交互为例，我们自己定义&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;表达题库提供的能力协议：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MatrixClient&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;AddUpdateBook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddUpdateBookRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MatrixResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;UpdateBookState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UpdateBookStateRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MatrixResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;AddUpdateItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddUpdateItemRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MatrixResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;UpdateItemState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;itemIds&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MatrixResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后有两份实现&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;真实的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MatrixClientImpl&lt;/code&gt;，生产使用&lt;/li&gt;
  &lt;li&gt;假的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MockMatrixClient&lt;/code&gt;，测试时使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类似地，其它形式的外部依赖，也可以这么解决。付出的额外成本是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;定义&lt;/li&gt;
  &lt;li&gt;一个调用真实接口的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;implementation&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个成本是非常小的，因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;的定义就是原方法签名的拷贝，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;implementation&lt;/code&gt;只是简单地返回真实调用。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MockMatrixClient&lt;/code&gt;怎么搞后面再介绍。&lt;/p&gt;

&lt;p&gt;值得讨论的问题是，换位思考下，作为服务提供方时，我们是否应该提供&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface+implementation&lt;/code&gt;，而不是只提供&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;implementation&lt;/code&gt;？&lt;/p&gt;

&lt;p&gt;乍一看，前者更好。但更推荐后者，因为一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;往往有多个方法，但多数场景下，并不会用到全部方法。一个大而全的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;反而让使用方背负过多负担。使用方根据需求定义自己的小&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;，成本更低。&lt;/p&gt;

&lt;h3 id=&quot;用例的编写&quot;&gt;用例的编写&lt;/h3&gt;

&lt;h4 id=&quot;收集用例&quot;&gt;收集用例&lt;/h4&gt;

&lt;p&gt;产品 &amp;lt; 研发 &amp;lt; QA：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;产品给规则(和典型case)&lt;/li&gt;
  &lt;li&gt;研发单测覆盖主干case&lt;/li&gt;
  &lt;li&gt;QA覆盖各种情形的case&lt;/li&gt;
  &lt;li&gt;bug反馈&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;建议：当修复qa反馈的bug后，应该考虑落地成代码内的测试用例，方便后续回归。（当因某个路段护栏坏了掉进沟里，把车吊上起之后，还想把护栏补一补，对吧？）&lt;/p&gt;

&lt;h4 id=&quot;保持独立&quot;&gt;保持独立&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一个测试方法对应一个case&lt;/li&gt;
  &lt;li&gt;用例之间不共享数据、状态&lt;/li&gt;
  &lt;li&gt;线程安全，可并发跑测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;测试代码与业务代码分离&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文件独立，测试代码写在XXX_test.go里&lt;/li&gt;
  &lt;li&gt;包独立, 业务为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;package service&lt;/code&gt;，对应测试应为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;package service_test&lt;/code&gt;。
    &lt;ul&gt;
      &lt;li&gt;独立包的好处是编译后成的生产用的可执行文件内不会包括&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt;相关代码。&lt;/li&gt;
      &lt;li&gt;减少包互相依赖的可能性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;单测覆盖率&quot;&gt;单测覆盖率&lt;/h3&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;cd app/service&lt;/li&gt;
  &lt;li&gt;go test -coverprofile=c.out&lt;/li&gt;
  &lt;li&gt;go tool cover -html=c.out&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，覆盖率是statements，不是branches。&lt;/p&gt;

&lt;p&gt;多少合适？&lt;/p&gt;

&lt;p&gt;覆盖率不是追求的目标，作为研发，&lt;strong&gt;覆盖主干case&lt;/strong&gt;是目标。但这个目标不易量化和评价。因此暂且用覆盖率代替，个人想法：60%及格，80%良好。&lt;a href=&quot;https://github.com/avelino/awesome-go&quot;&gt;awesome-go&lt;/a&gt;要求项目测试覆盖率达到80% 以上才有资格入选。Go社区两个常用库的覆盖率情况：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;gin:  98%&lt;/li&gt;
  &lt;li&gt;gorm: 78%&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mock生成工具&quot;&gt;mock生成工具&lt;/h3&gt;

&lt;p&gt;利用&lt;a href=&quot;https://github.com/golang/mock&quot;&gt;mockgen&lt;/a&gt;，只要有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;，就能自动生成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;implementation&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mockgen &lt;span class=&quot;nt&quot;&gt;-source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;search.go &lt;span class=&quot;nt&quot;&gt;-package&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;thirdcall &lt;span class=&quot;nt&quot;&gt;-destination&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;search_mock.go
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;search.go&lt;/code&gt;内的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;进行mock，生成实现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;search_mock.go&lt;/code&gt;，其package为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thirdcall&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注意，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;search_mock.go&lt;/code&gt;为自动生成的代码，任何时候都不应人工修改它。当源&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt;有变化时，应重新执行上述命令。&lt;/p&gt;

&lt;p&gt;mock生成的代码虽然是固定的，其行为表现却是高度可制定的。可以在测试代码里直接指定被Mock对象的行为，如：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// 执行SearchItem时传ctx和任意参数，都返回指定的resp和nil：&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;algoService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXPECT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;SearchItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gomock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 执行SearchItem时传ctx和任意参数，sleep两分钟，然后返回nil, nil。模拟服务超时。&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;algoService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thirdcall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewMockAlgorithmService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;algoService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;EXPECT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;SearchItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gomock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;DoAndReturn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;searchpage0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SearchItemRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;searchpage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KitcSearchItemResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Minute&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;AnyTimes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;测试的成本&quot;&gt;测试的成本&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;项目初期，更长的开发时间&lt;/li&gt;
  &lt;li&gt;更高的技能要求，对语言、对设计&lt;/li&gt;
  &lt;li&gt;更煎熬的心理：
    &lt;ul&gt;
      &lt;li&gt;长短期思维的博弈&lt;/li&gt;
      &lt;li&gt;个人vs团队,前人vs后人&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 26 Apr 2020 12:15:09 +0800</pubDate>
        <link>https://blog.yuzhi.run/computer/2020/04/26/go-unit-test.html</link>
        <guid isPermaLink="true">https://blog.yuzhi.run/computer/2020/04/26/go-unit-test.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>协程在手，并发不愁</title>
        <description>&lt;ul&gt;
  &lt;li&gt;概念与实现&lt;/li&gt;
  &lt;li&gt;协程的使用&lt;/li&gt;
  &lt;li&gt;vs线程进程&lt;/li&gt;
  &lt;li&gt;协程的优点&lt;/li&gt;
  &lt;li&gt;kotlin的协程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2019.09.20在团队的分享)&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;概念与实现&quot;&gt;概念与实现&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;运行在单线程中的&lt;strong&gt;并发&lt;/strong&gt;代码段，或：&lt;/li&gt;
  &lt;li&gt;一种&lt;strong&gt;用户态&lt;/strong&gt;的轻量级线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;bonus:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;并发 vs 并行&lt;/li&gt;
  &lt;li&gt;用户态 vs 内核态&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;概念与实现-1&quot;&gt;概念与实现&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;属性&lt;/strong&gt;: 拥有自己的&lt;strong&gt;寄存器上下文&lt;/strong&gt;和&lt;strong&gt;栈&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;行为&lt;/strong&gt;: 切换时，保存当前状态或恢复之前状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可不必与特定的线程绑定，可以在一个线程中暂停，并在另一个线程中恢复&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;bonus: 对比尾递归&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;概念与实现-2&quot;&gt;概念与实现&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;有栈协程(Stackful)：有自己的调用栈&lt;/li&gt;
  &lt;li&gt;如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Golang&lt;/code&gt;，栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB。&lt;/li&gt;
  &lt;li&gt;无栈协程(Stackless)：没有自己的调用栈&lt;/li&gt;
  &lt;li&gt;如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Python&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;。上下文通过CPS(continuation-passing-style)保存，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;中，就是一个&lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-continuation/index.html&quot;&gt;Continuation&lt;/a&gt;类，可想像成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Callback&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;bonus: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CPS&lt;/code&gt; vs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Direct Style&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;协程的使用&quot;&gt;协程的使用&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt; 版&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 接收producer的传参，执行后面代码，直到再次碰到yield后返回producer
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;[31;1m[consumer] %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;[0m 消费 %s &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# 发None启动消费者
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;[32;1m[producer]&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;[0m 生产 %s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# 暂停producer，并切换到consumer
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bonus: 对比子程序&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;协程的使用-1&quot;&gt;协程的使用&lt;/h1&gt;

&lt;p&gt;单步调试，注意&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send&lt;/code&gt;(1)之后跳到了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;(2)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/201909/coroutine_trace.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;协程的使用-2&quot;&gt;协程的使用&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kotlin&lt;/code&gt;版：&lt;a href=&quot;https://pl.kotl.in/7s9CC8kSa&quot;&gt;playgroud&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;channel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;GlobalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[producer] 生产 $x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;GlobalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[consumer] 消费 ${channel.receive()}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bonus: 为何&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kotlin&lt;/code&gt;版输出不同？&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;协程的使用-3&quot;&gt;协程的使用&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/201909/pipe.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;协程的使用-4&quot;&gt;协程的使用&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;子程序就是协程的一种特例。 —— Donald Knuth&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;或者说，协程是子程序的泛化。&lt;/p&gt;

&lt;h3 id=&quot;为什么&quot;&gt;&lt;em&gt;为什么?&lt;/em&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;vs-线程进程&quot;&gt;vs 线程、进程&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt; 应用程序的启动实例，有代码和打开的文件资源、数据资源、独立的内存空间。最小的资源管理单元。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;线程&lt;/strong&gt; 从属于进程，有自己的栈空间。最小的执行单元。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;表面看它们是语言特性，本质却是操作系统能力，通过API暴露给用户使用。&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;vs-线程进程-1&quot;&gt;vs 线程、进程&lt;/h1&gt;

&lt;h1&gt;&lt;img src=&quot;/img/201909/process_thread.jpg&quot; alt=&quot;&quot; /&gt;&lt;/h1&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;vs-线程进程-2&quot;&gt;vs 线程、进程&lt;/h1&gt;

&lt;h1 id=&quot;-1&quot;&gt;&lt;img src=&quot;/img/201909/coroutine_process.jpg&quot; alt=&quot;&quot; /&gt;&lt;/h1&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;vs-线程进程-3&quot;&gt;vs 线程、进程&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;谁来调度&lt;/li&gt;
  &lt;li&gt;何时切换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程/进程是os通过调度算法，保存当前的上下文实现暂停，重新开始的地方不可预期。每次CPU计算的指令数量和代码跑过的CPU时间有关，跑到os分配的cpu时间到达后就会被os强制挂起。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Coroutine&lt;/code&gt;是编译器的魔术，通过插入相关的代码使得代码段能够实现分段式的执行，重新开始的地方是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;关键字指定的，一次一定会运行到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;语句，所以本质是程序员决定何时挂起。&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;协程的优点&quot;&gt;协程的优点&lt;/h1&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// 可以轻松执行以下代码：&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;GlobalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${Thread.currentThread().name} is busy calculating&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 视机器配置，可能无法运行下面代码：&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${Thread.currentThread().name} is busy calculating&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;协程的优点-1&quot;&gt;协程的优点&lt;/h1&gt;

&lt;h3 id=&quot;开销小&quot;&gt;开销小&lt;/h3&gt;
&lt;p&gt;线程的时间成本可以拆解为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;切换本身&lt;/strong&gt;的开销，主要是&lt;strong&gt;寄存器保存和恢复&lt;/strong&gt;的成本，可腾挪的余地非常有限；&lt;/li&gt;
  &lt;li&gt;执行体的&lt;strong&gt;调度&lt;/strong&gt;开销，主要是如何在大量已&lt;strong&gt;准备好的执行体中选出谁获得&lt;/strong&gt;执行权；&lt;/li&gt;
  &lt;li&gt;执行体之间的&lt;strong&gt;同步与互斥&lt;/strong&gt;成本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程的空间成本可以拆解为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;执行体的&lt;strong&gt;执行状态&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;TLS（线程&lt;strong&gt;局部存储&lt;/strong&gt;）；&lt;/li&gt;
  &lt;li&gt;执行体的&lt;strong&gt;堆栈&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;显然，上述成本的比重各不相同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;默认情况下Linux 线程在数MB 左右，其中最大的成本是堆栈。如果一个线程 1MB，那么有 1000 个线程就已经到 GB 级别了。&lt;/li&gt;
  &lt;li&gt;执行体的调度开销，以及执行体之间的同步与互斥成本，也是一个不可忽略的成本。单位成本看起来不大，但扛不住次数太多。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://web.eece.maine.edu/~vweaver/projects/perf_events/overhead/fastpath2013_perfevents.pdf#page=4&quot;&gt;for core2 and modern Linux context switch may cost 5-7 microseconds.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;bonus: 每秒多少cs是合理的？&lt;/p&gt;

&lt;h3 id=&quot;不易出错&quot;&gt;不易出错&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;共享变量的同步锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程的任务分配是&lt;strong&gt;抢占式&lt;/strong&gt;，存在共享变量时，需要使用锁来保证线程间数据安全。
协程间任务分配是&lt;strong&gt;分发式&lt;/strong&gt;，本身无此问题，但&lt;strong&gt;如果运行在多线程中，依然有问题&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;No silver bullet&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;协程的应用&quot;&gt;协程的应用&lt;/h1&gt;

&lt;p&gt;协程主要应用场景是高性能的&lt;strong&gt;网络服务&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;来自客户端的请求包和服务器的返回包，都是网络IO；&lt;/li&gt;
  &lt;li&gt;过程中，需要访问存储来保存和读取自身的状态，也涉及本地或网络IO。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果用多线程来实现，如上所述，成本高，易出错。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;kotlin协程&quot;&gt;Kotlin协程&lt;/h1&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineContext&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EmptyCoroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineStart&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Job&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineContext&lt;/code&gt;: 可以理解为协程的上下文，其中一个实现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt;支持4种线程模式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Dispatchers.Default, 默认线程池, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CPU-heavy&lt;/code&gt;任务&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html&quot;&gt;Dispatchers.IO&lt;/a&gt;, 适合&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO-heavy&lt;/code&gt;任务&lt;/li&gt;
  &lt;li&gt;Dispatchers.Main, 主线程&lt;/li&gt;
  &lt;li&gt;Dispatchers.Unconfined, 没指定，就是在当前线程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;kotlinx.coroutines.*&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;GlobalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// launch a new coroutine in background and continue&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// non-blocking delay for 1 second (default time unit is ms)&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;World!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// print after delay&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello,&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// main thread continues while coroutine is delayed&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2000L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// block main thread for 2 seconds to keep JVM alive&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;参考资料&quot;&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md&quot;&gt;Kotlin Coroutines Design Proposal&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/basics.html&quot;&gt;Kotlin Coroutine Reference&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html&quot;&gt;Shared mutable state and concurrency&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do&quot;&gt;What does the “yield” keyword do&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=YrrUCSi72E8&quot;&gt;Deep Dive into Coroutines on JVM&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zingp/p/5911537.html&quot;&gt;协程及Python中的协程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/76d2f47b900d&quot;&gt;kotlin - Coroutine 协程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.itboth.com/d/J3uE7v/context-cpu-switch-context-switch-java&quot;&gt;从Java视角理解CPU上下文切换&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 20 Sep 2019 14:30:09 +0800</pubDate>
        <link>https://blog.yuzhi.run/computer/2019/09/20/coroutine.html</link>
        <guid isPermaLink="true">https://blog.yuzhi.run/computer/2019/09/20/coroutine.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>Queuing theory——排队的艺术</title>
        <description>&lt;p&gt;近期团队遇到相关场景，把2016年在堆糖做过的分享搬出来做了点完善，再分享一次：&lt;a href=&quot;/pdf/queuing-theory.pdf&quot;&gt;排队的艺术&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Jan 2019 14:30:09 +0800</pubDate>
        <link>https://blog.yuzhi.run/computer/2019/01/29/queuing-theory.html</link>
        <guid isPermaLink="true">https://blog.yuzhi.run/computer/2019/01/29/queuing-theory.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>像代数推导一般</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;In math we trust——张首晟&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;纯函数已然为函数式编程赢得了巨大优势，但这还不够。纯函数还只是一块基石，它和另一块基础——数据不可变，一道构筑了函数式编程蔚为壮观的独特风景：代数推导。这是函数式编程最吸引我的地方，因为，数学终于从编程语言或者计算机科学的背后走向前台，让我们可以像代数推导一般，进行现实问题的建模和编码。根据张首晟教授的说法，区块链的信任机制本质上是对数学的信任。我想，这一样适用于函数式编程，数学的严谨性让模型和代码质量有了更多保障。而数学的抽象，让貌似不同的事物有了变成一样的可能，提高了代码的普适性。&lt;/p&gt;

&lt;p&gt;学习函数式编程，与其说是学习某门具体的语言，不如说是学习如何运用代数结构描述现实事物，运用代数式子表达现实逻辑，运用代数推导求解现实问题。&lt;/p&gt;

&lt;h5 id=&quot;面向表达式语言&quot;&gt;面向表达式语言&lt;/h5&gt;
&lt;p&gt;代数，简而言之，研究的是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对象的&lt;strong&gt;集合&lt;/strong&gt;，这里的对象不是编程语言里的对象，反倒是更像类型。&lt;/li&gt;
  &lt;li&gt;用对象创建新对象的&lt;strong&gt;操作&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如，数构成集合，加减乘除构成操作。&lt;/p&gt;

&lt;p&gt;介绍纯函数时，我们知道了数学上的运算可以写成纯函数，如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f(x) = 2 * x + 3&lt;/code&gt;可以写成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def f(x: Int) = x * x + 3&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f(x, y) = x + y&lt;/code&gt;写成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def f(x: Int, y: Int) = x + y&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;集合里的对象，也就是语言的类型，后面再辟专门的章节讲述。先看看看代数的推导过程，蕴含了哪些值得借鉴的做法。以下是一道简单代数题的求解过程：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;已知函数f(x + 2) = 2x^2 - 5x + 1，求f(x)。
解：
设 t = x + 2, 则x = t - 2
∴ f(t) = 2 * (t - 2)^2 - 5 * (t - 2) + 1
∴ f(t) = 2 * (t^2 - 4 * t + 4) - 5 * t + 10 + 1
∴ f(t) = 2 * t^2 - 13 * t + 19
即，f(x) = 2 * x^2 - 13 * x + 19
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以发现：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先，在整个推导过程中，保持变量含义的不变，从头到尾的一致性。不会突然令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x = 9&lt;/code&gt;或别的值，当需要表达其它量时，启用新的变量t，并表述清楚t的来源&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t = x + 2&lt;/code&gt;，而不是复用原来的变量：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x = x + 2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有人把变量的&lt;strong&gt;不可变性&lt;/strong&gt;视为函数式编程最重要的特性，因为，就像上述推导一样，它喻示着过程的可省视性。仅仅通过阅读代码，就可以理解整个逻辑，而不是指令式编程那样，必须在脑子里”运行”代码。当大脑无法跟踪太多变量的变化时，不得不借用纸笔或调试工具来debug，只消几层的if判断就足以把人绕晕。有了不可变性，可以放心地将代码的各个部分分离开，独立解读，脑子里要保留、跟踪的信息几乎不随代码规模的增长而增加。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;其次，在值相同的情况下，符号和表达式可以互相替代，如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x + 2&lt;/code&gt;在通篇任意位置可以互相替代，这种替代在数学上叫&lt;strong&gt;换元&lt;/strong&gt;，用于辅助推导，并不改变语义。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若要在代码层面“换元”，则要求满足引用透明，引用透明辅助编译器对代码做优化，如果没有引用透明，编译器无法自由地替换“表达式“和“值”，因为前后两次的执行结果可能不同，哪怕结果完全一样，程序只能无奈地一次次对该表达式做求值操作。也不能改变表达式的顺序，因为前后两次的求值结果可能不一样，进而限制了程序的并发性。&lt;/p&gt;

&lt;p&gt;代数也是一门语言，它用数学模型描述现实世界，并解决逻辑问题。如果把它也看成一门编程语言，它应该归入什么类别呢？大概“面向表达式语言”是比较合理的分类。没错，表达式！看上面代数题的求解过程，本质是表达式的归约操作、合并同类项操作。所谓归约，就是将每个最内层可归约表达式用其值来替换，这样又形成了新的最内层可归约表达式，然后再对其进行归约，最后，整个程序全部被归约，仅留下最终结果。&lt;/p&gt;

&lt;p&gt;所以，用它解决问题的过程应该是，用数字或符号描述现实世界，如直角三角形的两和直角边长度分别为a和b，依据放之四海而皆准的公理，如勾股定理，构建它们的逻辑关系，如斜边&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c^2 = a^2 + b^2&lt;/code&gt;
，再用加减乘除等运算操作，简化、规约表达式，求得斜边长度。这一过程中，我们并没有过问这些变量寄存在哪里（有人直接在脑子里算，也有人要在纸上演算），也不关心它们是否复用了同一块内存，会不会被其它人错误地读写了。我们关心的是想要什么，得到结果的逻辑是什么，而不是如何赋值、如何改写变量。前者是人类擅长的，后者是机器擅长的。我们应让机器服务人类，而不是反过来，人类迁就机器。为此，我们需要一个工具，把高阶的人类思维忠实地转换为低阶的机器语言。&lt;/p&gt;

&lt;p&gt;函数式语言就是这样的工具，它有一个少为人知的别名，正是“面向表达式语言”。&lt;strong&gt;表达式&lt;/strong&gt;是值和逻辑（函数）的组合，讲究如何编织逻辑以创建新的值，执行的过程即是规约化得到最终结果的过程，如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;val total = sum(list)&lt;/code&gt;，sum是一个求和的运算逻辑，通过这个逻辑得到值&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum&lt;/code&gt;。 与之相反的是&lt;strong&gt;指令式&lt;/strong&gt;，用一系列的执行单元，告诉计算机如何改变指令计数器、数据存储器、当前计数状态等，通过状态的改变得到最终结果，如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list.sum()&lt;/code&gt;，sum是个运算指令，它不返回计算的值，而是改变了某个状态，通过读取这个状态的地址得到结果。&lt;/p&gt;

&lt;p&gt;指令式语言让我们从低级语言的内存、栈、寄存器等概念中解脱，却依然是指令运行过程的封装：循环、锁、线程、并发。函数式语言则进一步抽象，更多地让编译器、解析器处理这些概念，让人腾出更多精力关注数据模型、关注业务逻辑。&lt;/p&gt;

&lt;h5 id=&quot;函数的组合&quot;&gt;函数的组合&lt;/h5&gt;
&lt;p&gt;他山之石，可以攻玉。我们回头再挖掘下代数里可以借鉴的特质。&lt;/p&gt;
&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果f(x)=3x-1，且g(x)=x^3+2，那么f(g(3))的值是多少？
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;间接的做法是，先求得&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g(3) = 29&lt;/code&gt;，进而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f(g(3)) = f(29) = 86&lt;/code&gt;。那么，有没有直接的做法呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/compose_func.png&quot; alt=&quot;compose&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了直接计算&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f(g(x))&lt;/code&gt;，我们得&lt;strong&gt;组合&lt;/strong&gt;（Composition）f和g这两个函数。由于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g(x)&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f(x)&lt;/code&gt;的输入，可以把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f(x)&lt;/code&gt;的各个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;替换为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g(x)&lt;/code&gt;，得到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f(g(x)) = 3g(x)-1 = 3x^3+5&lt;/code&gt;，即是图中绿线所表示的函数。&lt;/p&gt;

&lt;p&gt;在Scala里，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Function1&lt;/code&gt;接口定义了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compose&lt;/code&gt;方法和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;andThen&lt;/code&gt;方法，均可以用来组合单参数函数。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f(g(x))&lt;/code&gt;可以写成：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;f: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;g: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fg&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compose&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fg2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;andThen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意，”_“表示Eta expansion。&lt;/p&gt;

&lt;p&gt;组合看上去再自然不过了，以至于我们不觉得有什么特别或厉害的。然而，稀松平常的组合却透露了编程的本质。&lt;/p&gt;

&lt;p&gt;我们是如何解决问题的？每当碰到复杂的问题，就把它分解为更小的问题，直到问题足够小，小到我们可以写代码解决它。然后，再组合这些小颗粒度的代码，形成原始问题的解决方案。问题规模的限制并不是计算机强加给我们的，而是人类大脑的限制。1956年发表的著名论文《神奇的数字 7，加减 2：人类信息加工容量的某些局限》指出，不管记忆的内容怎么变化，是数字，字母，数字 + 字母，还是从 1000 个单音节单词中随机选，人们在记忆这些材料的时候，大概只能记住 5-9 个。所以，我们必须把一次性可以处理的代码块规模控制在大脑可以接受的程度。所谓”优雅代码”，不是结构清晰、简洁所能概括的，更切中要害的说法是，可被有限的大脑带宽处理。&lt;/p&gt;

&lt;p&gt;分解本身不是目的，解决问题需要重组这些子块，如果无法重新组合，分解的意义就不存在。什么样的函数能组合呢？显然，一个函数的输出类型必须和另一个函数的输入类型保持一致。至少在函数式语言内，这是”类型”概念存在的根本原因。有关类型，我们后面再详谈。&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Oct 2018 12:15:09 +0800</pubDate>
        <link>https://blog.yuzhi.run/computer/2018/10/29/fp-algebra.html</link>
        <guid isPermaLink="true">https://blog.yuzhi.run/computer/2018/10/29/fp-algebra.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>纯函数的好处</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;哦，雪白的纯朴具有何等大的威力！——济慈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;纯函数的两个优良品质，为它赢得了很多优势。&lt;/p&gt;

&lt;h5 id=&quot;引用透明&quot;&gt;引用透明&lt;/h5&gt;
&lt;p&gt;以直接用函数运行的结果替代函数表达式本身而不改变程序的最终结果，称为引用透明（Referential Transparent）。如：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;length&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;world&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;length&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果把第二处”hello”.length换成x，或者反过来，把第二处y换成”world”
.length，并不改变z的值。这似乎是很显然的事，却是以length是纯函数为前提的，换成随机数生成函数、获取当前时间的函数，就不能替换。如果改变函数范围外的变量，也会破坏引用透明，如：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;记忆&quot;&gt;记忆&lt;/h5&gt;
&lt;p&gt;引用透明很好，可避免函数的反复执行，但毕竟还是需要人工替换，如果函数自身能智能地实现一次计算，多处使用就好了。可喜的是，对于纯函数，编译器可以实施名为”记忆”（Memoization)的优化技术，正是达到这个效果。特别是执行很费时的函数，把结果缓存起来，当下次用相同入参调用时，便可直接返回缓存的结果，不再重新计算，大大提高程序的效率。当然，通过把入参和结果作为键值对保存在Map中，我们可以自己实现缓存过程，方便控制缓存策略。用通常不太缺乏的内存空间换取宝贵的计算时间，这是计算机科学里常用的”伎俩”。&lt;/p&gt;

&lt;h5 id=&quot;缓求值&quot;&gt;缓求值&lt;/h5&gt;
&lt;p&gt;缓求值(Lazy Evaluation)，指尽可能地推迟求解表达式，是函数式编程语言常见的一种特性。Scala通过lazy关键字声明缓求值。缓求不会在遇到表达式时就触发运行，而是在用到的时候才真实计算。缓求在记忆之外，为昂贵的运算提供了另一种优化手段。如，以下判断质数的函数，虽然表达式&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isPrimeSlow(num)&lt;/code&gt;在if判断前面，但只有当输入为奇数时，才会真正被执行。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isPrimeSlow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isPrime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;lazy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isPrimeSlow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;缓求值在集合中的应用更能体现其价值。熟悉Python的同学知道生成器（generator）的概念，应用了缓求了集合与之类似，对于很大的集合，不是一次性生成（或者说根本就没有生成），只是需要的时候才吐出所需的元素。对比intsEager和intsLazy执行效果，便会发现对于寻找大于5的第一个数6而言，intsEager一次性生成了10万个元素，但比6大的元素对于求解结果毫无帮助，白白浪费了内存，简直是暴殄天物。如果把这个形式推到极限，对于有无限个元素的集合，似乎只有缓求方式才能胜任了。这下我们发现了，相比于”记忆”，缓求倒过来了，它是以临时计算来免除需要事先准备好的内存。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;intsEager&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;intsEager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;intsLazy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;intsLazy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上，是纯函数为语言提供的额外特性，可以认为是一些与身俱来的优势。接下来分析纯函数为编程实践带来的好处，如何帮助提高代码质量，提高开发效率。&lt;/p&gt;

&lt;h5 id=&quot;纯函数更易推断&quot;&gt;纯函数更易推断&lt;/h5&gt;
&lt;p&gt;纯函数的签名已经把它的目的和盘托出了，不需要细看内部实现，就可以相信它没有多干其它小动作，所以不会有超乎签名的副作用和意外效果。经验不足的同学甚至在java的getter类方法中做了写操作：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;visit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;哪怕老手也难免有被糊弄的时候。比如，出乎意料，下面这段代码会访问网络，因为URL的hashCode方法会尝试解析域名。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;notPure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;URL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://example.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Sets&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MalformedURLException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//ignored&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;纯函数就没有这些问题，这是多么大的心智减负。&lt;/p&gt;

&lt;h5 id=&quot;纯函数更易组合&quot;&gt;纯函数更易组合&lt;/h5&gt;
&lt;p&gt;函数的组合（compose)，简单而言，就是把若干函数按一定顺序拼接组成新函数。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;后续会介绍，组合在函数式编程中有着举足轻重的地位。且看组合的具体应用——优雅的链式调用：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doThis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;thenThis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;andThenThis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;doThisToo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;andFinallyThis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果不是纯函数，很难想象可以放心地写出这段代码。doThis(a)如果改变了a，会怎么影响doThisToo的行为？如果各步骤共享了状态，拋了异常，代码的整体行为表现是怎样的？正确评估这些问题极其消耗心力。而纯函数的确定性，可以让后续步骤放心地依赖前面步骤的输出，代码的作用如字面语义一样跃然纸上。&lt;/p&gt;

&lt;h5 id=&quot;纯函数更易测试和定位问题&quot;&gt;纯函数更易测试和定位问题&lt;/h5&gt;
&lt;p&gt;唯一能影响函数行为的只有输入参数，没有不为人知的魔法，没有数据库、磁盘读写，所以不用关心函数外的环境因素，进而在不同人的电脑上debug效果一样。同理，指令式编程过程中费时费力的单步调试，此时不再重要了，关心函数的输出即可。&lt;/p&gt;

&lt;h5 id=&quot;纯函数更易并发&quot;&gt;纯函数更易并发&lt;/h5&gt;
&lt;p&gt;纯函数保证值不变性，值一旦生成就不再改变，无论是同一线程还是多个线程，都不允许修改。所以连锁都免了，更没有死锁或数据竞态问题了。&lt;/p&gt;

&lt;p&gt;因为没有副作用，从出入参就可以看出函数之间的依赖关系，如果前后没有数据依赖，其先后顺序便可以交换，或者在多个线程中独立运行而不相互干涉。如下面代码中，f、g、h在字面上的先后顺序是固定的，但编译器完全可以根据需要改动实际执行顺序，或者优化为并发执行。如果它们有副作用，比如暗地里修改了共享的状态，就不能这么轻巧地优化了。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们从回顾众所周知的函数开始，再区分纯函数和非纯函数，进而专注于纯函数式的特点、好处。接下来，如何不是特别说明，提到函数时指的就是纯函数。函数式编程，更准确的说法应该是”纯函数”式编程。纯函数所带来的好处构成了函数式编程的核心优势，这点后续将有更多体现。&lt;/p&gt;
</description>
        <pubDate>Sat, 20 Oct 2018 12:15:09 +0800</pubDate>
        <link>https://blog.yuzhi.run/computer/2018/10/20/why-pure-fp.html</link>
        <guid isPermaLink="true">https://blog.yuzhi.run/computer/2018/10/20/why-pure-fp.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>纯函数的特质</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;大人者，不失其赤子之心者也。——孟轲&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;数学家比较幸福的一点是，他们研究的函数是”纯净”的。没有异常，没有意外，同样的入参一定返回同样的结果。如果不是，那就是人出错了。&lt;/p&gt;

&lt;p&gt;编程里的函数就没这么纯粹，会遇到无法处理的输入，会在中途拋出异常，在返回值之外会留下别的痕迹。这些不确定性因素，使得人们不能放心大胆地使用函数。因此，需要一个标准，把有这类特点的问题函数识别出来，让”纯函数”发扬光大。&lt;/p&gt;

&lt;p&gt;“纯函数”具备以下性质：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;确定性&lt;/strong&gt; 相同的入参，一定返回相同结果，不受内部隐藏状态、隐藏值的影响，也不受任何I/O的影响。多次调用的结果保持一致，说明纯函数具有幂等性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;无副作用&lt;/strong&gt; 运行函数不能引发可辨别的副作用或输出，如修改可变对象，或写入I/O设备。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;展开来讲，纯函数应该避免：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;读取函数之外的任何值，如所在类的属性，或全局变量。&lt;/li&gt;
  &lt;li&gt;修改函数之外的任何对象，如所在类的属性或全局变量。&lt;/li&gt;
  &lt;li&gt;依赖任何I/O操作，如从本地文件、数据库、API、屏幕等途径读取或写入内容。&lt;/li&gt;
  &lt;li&gt;修改输入参数。&lt;/li&gt;
  &lt;li&gt;拋出异常。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回顾之前的定义，对于数学意义上的函数，定义域的元素总能唯一对应值域的元素，加上数学是一种逻辑符号语言，自然没有副作用。那么不难理解，表达这些数学含义的代码函数（scala.math._里定义的函数）也应该是纯函数，如：square, min, max, abs等。或者你自定义的计算，如：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;squareSum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;很多常用类的方法，并不改变方法之外的类属性，也不进行I/O操作，也是纯函数。如String的charAt, isEmpty, length；集合类型的drop（没错，drop也是）, filter, map等。&lt;/p&gt;

&lt;p&gt;再来看看纯函数的反例。同样是数学上的运算，如果函数拋出异常，就不纯了，因为异常时没有和输入对应的结果。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;divide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;divide&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;x:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;y:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;divide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;ArithmeticException&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;zero&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也不是所有集合类的方法都是纯函数，foreach方法就是专门为副作用准备的。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Unit在scala中表示”没有东西”，如果一个函数接受了输入，但不返回任何结果，那么它做的工作就只能是”副作用”了。&lt;/p&gt;

&lt;p&gt;常见的非纯函数还有：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;getDayOfWeek，getHour，getMinute等方法，因为不同时刻调用它们得到的结果不同。&lt;/li&gt;
  &lt;li&gt;scala.util.Random中用于生成随机数的nextInt，因为返回值依赖了输入之外的隐藏状态。&lt;/li&gt;
  &lt;li&gt;I/O操作，如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def println(x: Any): Unit&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def readLine(): String&lt;/code&gt;。所以，当发现签名的入参为空或出参为Unit时，就得擦亮眼睛了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，面向对象语言里常见的setter方法，或改变了所在对象的状态的方法也不是纯函数，如：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;pureFunction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;至此，我们已经能辨别纯函数，可纯函数有什么好处呢？&lt;/p&gt;
</description>
        <pubDate>Fri, 05 Oct 2018 12:15:09 +0800</pubDate>
        <link>https://blog.yuzhi.run/computer/2018/10/05/what-is-pure-function.html</link>
        <guid isPermaLink="true">https://blog.yuzhi.run/computer/2018/10/05/what-is-pure-function.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>默克尔树（Merkle Tree）</title>
        <description>&lt;p&gt;默克尔树（Merkle Tree）的定义很简单，却是区块链技术领域的重要概念。它使得大规模的分布式区块网络成为可能，也让普通机器可以成为网络节点。&lt;/p&gt;

&lt;h3 id=&quot;什么是默克尔树&quot;&gt;什么是默克尔树&lt;/h3&gt;
&lt;p&gt;数据结构上，它是一种特殊的二叉树(也可以是多叉树)，设计如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;叶子节点的值是数据的哈希值。&lt;/li&gt;
  &lt;li&gt;非叶子节点的值是其所有子节点的哈希值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/2018.3/merkle_tree.png&quot; alt=&quot;&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;hash代表哈希算法，如MD5，SHA系列等，可把任意长度的数据转换为固定长度的哈希值。&lt;/li&gt;
  &lt;li&gt;L1, L2等是叶子节点对应的数据，直接作为哈希算法的输入。&lt;/li&gt;
  &lt;li&gt;非叶子节点的哈希输入为所有对应子节点哈希串的拼接。&lt;/li&gt;
  &lt;li&gt;最终形成唯一的根节点，称为默克尔根(Merkle Root).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上图叶子节点数为4，恰好每一层都有完整输入。如果叶子节点数量不是2的次方，即不能形成满二叉树，怎么处理呢？&lt;/p&gt;

&lt;p&gt;有多种处理“孤立”叶子节点的方式。一种方案是不断重复最后一个节点，直到整体数量达到2^n
个。这种方案的想法比较直接，缺点也很明显，多做了很多无用功。比较好的方法是，把“孤立”节点提升到更高层次中。具体提到哪一层，要看叶子节点的数量情况，下图展示了5-7个叶子节点的情况：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     ┌───┴──┐          ┌────┴───┐            ┌─────┴─────┐
  ┌──┴──┐   │       ┌──┴──┐     │         ┌──┴──┐     ┌──┴──┐
┌─┴─┐ ┌─┴─┐ │     ┌─┴─┐ ┌─┴─┐ ┌─┴─┐     ┌─┴─┐ ┌─┴─┐ ┌─┴─┐   │
       (5)                 (6)                    (7)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;默克尔树的特性&quot;&gt;默克尔树的特性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;对变动敏感&lt;/strong&gt;。任何细微的变动都会引发叶子节点哈希值的变化，依次向上传导，最终导致根节点的变动。因此，像普通哈希一样，可以用来验证数据拷贝的一致性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;快速定位差异&lt;/strong&gt;。二叉树查询的时间复杂度为O(logN)，沿着根节点向下对比，可以非常高效地确定具体是哪个（些）叶子的数据有差异。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;默克尔证明&lt;/strong&gt;。如图，要证明数据d3在数据集中，只要知道节点c,i,n（白色节点）的值，即可通过重新计算节点d,j,m的值，进而计算根节点的值，再和给定的根节点对比，判断d3是否属于该数据集。不需要拿到所有数据，即可完成此验证。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/2018.3/merkle_proof.jpeg&quot; alt=&quot;&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;默克尔树的应用&quot;&gt;默克尔树的应用&lt;/h3&gt;

&lt;h4 id=&quot;p2p下载&quot;&gt;P2P下载&lt;/h4&gt;
&lt;p&gt;在p2p下载出现之前，整个文件的数据都从一个中心节点上获取。这个中心节点的资源和稳定性常常成为瓶颈点，一旦下载异常，整体文件都需要重新下载。p2p
网络出现后，一个大文件被分割成许多小块，编号后分布在不同的资源节点上，下载操作同时从多个节点上进行，每一块都有对应的哈希值，用于下载后的检验。就算一个块出错，只需要重新下载这小块就行，而不需要重新下载整个文件。&lt;/p&gt;

&lt;p&gt;问题是如何确保每一块的哈希值本身是正确的呢，在p2p
网络中，任何人都可以成为提供下载资源的节点，无法确保数据本身或其哈希值没被恶意修改。一种方式是由可靠的权威节点提供这些小块数据的哈希值，可以从做任意节点下载资源，但只从权威节点下载哈希值。这当然可行，但对权威节点的依赖还是太大了。&lt;/p&gt;

&lt;p&gt;默克尔树能解决这个问题呢？把小块数据作为叶子节点，构建默克尔树，只要根节点的哈希值从可信节点下载，剩下所有数据和节点哈希值都可以从任意节点下载。各个分支的值可以对其子树进行检测，根的值则可以对整个默克尔树进行检测。这样既可以各个分支并行独立处理，又确保了整个大文件的完整性。&lt;/p&gt;

&lt;h4 id=&quot;比特币交易验证&quot;&gt;比特币交易验证&lt;/h4&gt;

&lt;p&gt;比特币的设计里，区块头是不包含交易（Transaction）信息的，关于交易的数据只是交易构建的默克尔树的根节点。
&lt;img src=&quot;/img/2018.3/blockchain.jpeg&quot; alt=&quot;&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而比特币网络的轻量客户端（如钱包）又不存储完整的区块数据，仅下载区块头，就能验证某笔交易是否被打包到链上。这是如何做到的呢？客户端验证步骤如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先对交易数据进行哈希。&lt;/li&gt;
  &lt;li&gt;然后咨询完整节点：这个哈希值对应的交易是否在第index
个区块中？&lt;/li&gt;
  &lt;li&gt;完整节点的区块不会直接返回在或不在的结论，而是返回一个&lt;em&gt;默克尔证明&lt;/em&gt;（重新计算根节点所需的路径）。&lt;/li&gt;
  &lt;li&gt;客户端验证这个”默克尔证明”，即独立计算根节点的哈希值。&lt;/li&gt;
  &lt;li&gt;对比区块头中的哈希值与计算结果是否相同。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于n笔交易而言，路径节点数只要log2(n)，无论是查找还是数据传输都是一个巨大的效率提升。不妨试算一下，假设某个区块包含32768笔交易，每笔交易占256字节，则所有交易大小为8M
，而路径数为15，每个哈希占32字节，则路径大小仅为480字节，差距高达5个数量级。&lt;/p&gt;

&lt;p&gt;值得指出的是，比特币网络的任何节点都不会也没必要相信其它节点，节点只能依赖事先约定的协议独立地验证来自网络的数据。这个验证的最终基础正是数学。用张首晟的话说：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;In math, we trust.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然，默克尔树早在比特币之前就已经广泛使用了，分布式代码版本工具Git，以及开源数据库Apache Cassandra均有使用。&lt;/p&gt;

&lt;h3 id=&quot;默克尔树的实现&quot;&gt;默克尔树的实现&lt;/h3&gt;
&lt;p&gt;为了加深理解，用python实现了简单的默克尔树，包含构建、验证和查找功能。数据结构本身比较清楚明了，关键代码做了注释，这里不再讨论。可直接到&lt;a href=&quot;https://github.com/vitrun/pok/tree/master/merkletree&quot;&gt;github&lt;/a&gt;阅读源码。&lt;/p&gt;

&lt;h3 id=&quot;参考文档&quot;&gt;参考文档&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;https://github.com/adjoint-io/merkle-tree&lt;/li&gt;
  &lt;li&gt;https://en.wikipedia.org/wiki/Merkle_tree&lt;/li&gt;
  &lt;li&gt;https://brilliant.org/wiki/merkle-tree/&lt;/li&gt;
  &lt;li&gt;https://juejin.im/entry/5a2e1135f265da432f311168&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 08 Jul 2018 14:30:09 +0800</pubDate>
        <link>https://blog.yuzhi.run/computer/2018/07/08/merkle-tree.html</link>
        <guid isPermaLink="true">https://blog.yuzhi.run/computer/2018/07/08/merkle-tree.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>编程界的剑气之争</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/2017.4/kungfu.jpeg&quot; alt=&quot;&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;华山派曾有剑宗和气宗之分。双方你争我夺，势不两立。是权力之争，也是道统和武力之争。&lt;/p&gt;

&lt;p&gt;咱编程界也有指令式程序（如，面向对象）和函数式编程两派。他们的关系虽不至于剑拔弩张，却也相当紧张。表面是语言风格之争，其实是方法论之争。&lt;/p&gt;

&lt;p&gt;话说，当年高级语言诞生不久，场面就开始混乱了。面向对象派，又称bottom-up派，他们从底层硬件开始向上走，在不牺牲性能的前提下，逐步增加抽象层级，不断接近数学。Fortran, C/C++, Pascal, Java以及C#等等都属于这派。函数式编程派，又称top-down派，坚持从数学出发，逐渐减少抽象级别，以接近现实问题，并获得硬件支持，为了保持概念完整，牺牲了部分性能。其拥护者有Algo，Lisp，Smalltalk和Haskell等。&lt;/p&gt;

&lt;p&gt;双方坚持信仰，互相揭短。top-down说，哎呀，别这么快向硬件妥协，那会把选择局限在少数几个不可逆的设计中；而且，mutable太可怕了，尤其是在并发情况下，冷不防就来个意外。bottom-up派则说，别给我套这么多数学，我很难兼顾垃圾回收、函数调用……而且，性能、性能、性能，我不能牺牲任何性能；immutable太理想化了，毕竟现实世界在变，试想，如果date和random不变，调用它们有什么意义？&lt;/p&gt;

&lt;p&gt;计算机科学家Erik Meijer说，每当新语言出现时，他总会看看技术规范。这对他来说，也许就像喝着咖啡看报纸，轻松自如。但他在一次分享中说，有一门语言，他根本读不懂，一看就犯困，比什么安眠药都更有效。你可能会觉得那一定是门高深的语言，然而，这门语言就是很多人熟悉的Java8。他觉得lambda，method reference这些东西实在太复杂了。怎么办？每当碰到复杂的东西，他就听Leslie Lamport（图灵奖获得者）的话：“我们应该多用点数学。”&lt;/p&gt;

&lt;p&gt;他知道，大部分程序员都惧怕数学，就更别说如何用数学理解语言，如何在编码中应用数学。所以他上台演示，分享了《Category Theory, The essence of interface-based design》。老头子精力十足，对照着讲数学概念和函数式编程中的语言概念，很是精彩。时不时揶揄下Java：lambda演算早在1928年就提出了，Java作者Gosling一度声称没必要支持lambda，但最终还是在Java8中支持了，这是为什么？因为我们畏惧数学。但我们不应该畏惧，搞数学的人都是很聪明的，我们应该从他们身上偷师点东西。&lt;/p&gt;

&lt;p&gt;年迈的Java徘徊良久，终于接纳函数式编程；年轻的Scala和F#是与身俱来的多面手，两边讨好；新生的Kotlin长了一张面向对象的脸，却又兼俱一点函数式气质。争吵了近70年，两派终于开始弥合了。&lt;/p&gt;

&lt;p&gt;纵是阳春白雪， 也有下里巴人的时候。多核时代下并发需求的普及，以及日益复杂的软件架构，使得指令式编程力不从心。我们需要更有力的武器。Brian Beckman说，我们将无可避免地接触monad，因为函数式编程正迎面呼啸而来。&lt;/p&gt;

&lt;p&gt;这段历史似曾相识，关于剑气宗的高下，岳不群有段论述：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;剑宗功夫易于速成，见效极快。大家都练十年，定是剑宗占上风；各练二十年，那是各擅胜场，难分上下；要到二十年之后，练气宗功夫的才渐渐的越来越强；到得三十年时，练剑宗功夫的便再也不能望气宗之项背了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但我们是文明的现代人，何必争个你死我活。我们要融合，要扬长避短。总有一天，犹太教、基督教和伊斯兰教的朋友们会在他们共同的圣地——耶路撒冷，愉快地生活的，是不是？哦弥陀佛！&lt;/p&gt;

&lt;p&gt;有个问题摆在所有程序员面前：如何提高软件质量？这是个可以写好几本书的话题。我敢打包票的是，这些书都会讲code review、unit test、 QA……其中单元测试（或者包括集成测试）的争议最大。写测试确实费时费力，又不一定讨好。我认识的人中就有坚决肯定和坚决否定两种极端。我认为这是个性价比的问题，如果能自动生成单元测试就好了。于是，一度想用AI搞个这样的项目（事实是确实有人在研究这个，比如randoop，曾测出了jdk的bug）。但转念一想，又打住了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;People are always more willing to work harder than they have to than to work smarter than they’re able to.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;质量的关键并不在测试之类的防御性措施上。测试是有意义的，但就像公路两边的防护栏，能防止你掉下悬崖，却并不能把你带向目的地。我们应该回到业务本身，琢磨如何更优雅地设计和实现它，这是科学、艺术，是编程之美，也是我一直提倡design review的原因。但关于设计以及架构，我发现的更多是其中的“艺术”成分，也就是依靠经验和模仿习得的那些。是否有完整的章法和可言传的套路呢？我们需要更多科学来指导代码的设计和组织。与其说我们需要函数式编程，不如说我们需要更高的视角看待编程。&lt;/p&gt;

&lt;p&gt;带着这个疑问，我撞见了category theory，中文叫范畴论，不知道这个鬼见了都犯愁的理论，能多大程度解决问题。但我愿意一试，没准某一天，我能以气御剑？&lt;/p&gt;

&lt;p&gt;注：上面都是废话，本文重点是以下链接：&lt;/p&gt;

&lt;p&gt;REF.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;https://www.infoq.com/presentations/Simple-Made-Easy&lt;/li&gt;
  &lt;li&gt;https://www.youtube.com/watch?v=ZhuHCtR3xq8&lt;/li&gt;
  &lt;li&gt;https://www.youtube.com/watch?v=JMP6gI5mLHc&lt;/li&gt;
  &lt;li&gt;https://ykode.id/making-sense-of-category-theory-6f901e39fa3c&lt;/li&gt;
  &lt;li&gt;https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 06 Dec 2017 12:15:09 +0800</pubDate>
        <link>https://blog.yuzhi.run/computer/2017/12/06/fp-vs-op.html</link>
        <guid isPermaLink="true">https://blog.yuzhi.run/computer/2017/12/06/fp-vs-op.html</guid>
        
        
        <category>computer</category>
        
      </item>
    
  </channel>
</rss>
